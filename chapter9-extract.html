<h1 id="leanpub-auto-chapter-9---digging-deeper" class="chapter">Chapter 9 - Digging deeper</h1>

<p>Now that we have a good grasp of Go fundamentals, next we will delve deeper into the language and explore more advanced concepts. We’ll expand upon previously covered topics and introduce new techniques such as assertion, reflection, and Go’s new generics implementation, tools which should enhance our abilities as Go programmers.</p>

<h2 id="leanpub-auto-developing-with-functions" class="section">9.1 Developing with functions</h2>

<p>We’ve used functions a few times already. We’ve called functions from standard library packages such as <code>log</code> and <code>fmt</code> and we’ve also created functions in the examples ourselves.</p>

<p>Next, we’ll focus on some of the less common aspects of functions in programming languages, features which we do have in Go. Specifically, we’ll focus on function signatures including variadic arguments, and return styles, including multiple returns.</p>

<aside class="information blurb">
    <p>Note, that what we cover here, is equally applicable when working with <i>receivers</i>.</p>

</aside>

<h3 id="leanpub-auto-function-parameters" class="subsection">9.1.1 Function parameters</h3>

<p>Functions often accept values passed to satisfy parameters in the function signature. </p>

<p>In Go, when defining function parameters we need to specify both the variable name and its type.  To shorten the signature somewhat we can group parameters of the same type if it makes sense to do so, and it <b>isn’t</b> detrimental to the API.</p>

<p>The snippets below show ungrouped and grouped parameters.  See how in this case, grouping makes the ordering less intuitive.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="o">//</code> <code class="n">ungrouped</code> <code class="n">parameters</code>
<code class="linenos"> 2 </code><code class="k">func</code> <code class="n">normalParams</code><code class="p">(</code><code class="n">name</code> <code class="n">string</code><code class="p">,</code> <code class="n">age</code> <code class="nb nb-Type">int</code><code class="p">,</code> <code class="n">houseNumber</code> <code class="nb nb-Type">int</code><code class="p">,</code> <code class="n">address1</code> <code class="n">string</code><code class="p">,</code> <code class="n">address2</code> <code class="n">s</code>\
<code class="linenos"> 3 </code><code class="n">tring</code><code class="p">){</code>
<code class="linenos"> 4 </code>    <code class="o">...</code>
<code class="linenos"> 5 </code><code class="p">}</code>
<code class="linenos"> 6 </code>
<code class="linenos"> 7 </code><code class="o">//</code> <code class="n">grouped</code> <code class="n">parameters</code><code class="p">,</code> <code class="n">which</code> <code class="n">makes</code> <code class="n">the</code> <code class="n">API</code> <code class="n">a</code> <code class="n">bit</code> <code class="n">awkward</code> <code class="ow">in</code> <code class="n">this</code> <code class="n">example</code>
<code class="linenos"> 8 </code><code class="k">func</code> <code class="n">groupedParams</code><code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="n">address1</code><code class="p">,</code> <code class="n">address2</code> <code class="n">string</code><code class="p">,</code> <code class="n">houseNumber</code><code class="p">,</code> <code class="n">age</code> <code class="nb nb-Type">int</code><code class="p">){</code>
<code class="linenos"> 9 </code>    <code class="o">...</code>
<code class="linenos">10 </code><code class="p">}</code>
</pre></div>

</figure>


<p>Long function signatures can also be split with line breaks to improve readability. No escape character is needed when doing so.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="o">//</code> <code class="n">split</code> <code class="n">over</code> <code class="n">lines</code>
<code class="linenos"> 2 </code><code class="k">func</code> <code class="n">normalParams</code><code class="p">(</code>
<code class="linenos"> 3 </code>	<code class="n">name</code> <code class="n">string</code><code class="p">,</code> 
<code class="linenos"> 4 </code>	<code class="n">age</code> <code class="nb nb-Type">int</code><code class="p">,</code>
<code class="linenos"> 5 </code>	<code class="n">houseNumber</code> <code class="nb nb-Type">int</code><code class="p">,</code> 
<code class="linenos"> 6 </code>	<code class="n">address1</code> <code class="n">string</code><code class="p">,</code> 
<code class="linenos"> 7 </code>	<code class="n">address2</code> <code class="n">string</code><code class="p">,</code>
<code class="linenos"> 8 </code>	<code class="p">)</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="k">return</code>
<code class="linenos">10 </code><code class="p">}</code>
</pre></div>

</figure>


<aside class="information blurb">
    <p>Note the trailing comma which is required when the parameters (or arguments) are separated in this manner.</p>

</aside>

<h3 id="leanpub-auto-variadic-arguments" class="subsection">9.1.2 Variadic arguments</h3>

<p>Go functions can accept variadic arguments. A variadic argument comprises one or more values which are supplied to a single function parameter, building a slice of those values for use within the function body.</p>

<p>There can be only one variadic parameter in each function signature and it must be the last parameter.  It is also optional, so we can omit the argument if we wish.</p>

<p>A parameter which accepts variadic arguments is denoted by the <i>spread</i> operator, which precedes its type e.g. <code>...string</code>.</p>

<p>Within the function body, we will need to inspect the slice length to determine if one, multiple or no values were passed to the variadic parameter, and then handle those values accordingly.</p>

<p>Let’s demonstrate with an example function which includes a variadic parameter, in which we call the function four different ways to demonstrate its flexibility.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 84 - Passing values as variadic arguments</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"fmt"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="n">func</code> <code class="n">myVariadicFunc</code><code class="p">(</code><code class="n">name</code> <code class="n">string</code><code class="p">,</code> <code class="n">address</code> <code class="o">...</code><code class="n">string</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"Hello </code><code class="si">%s</code><code class="s2">!</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">name</code><code class="p">)</code>
<code class="linenos"> 7 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"Addresses:"</code><code class="p">)</code>
<code class="linenos"> 8 </code>	<code class="k">if</code> <code class="nb">len</code><code class="p">(</code><code class="n">address</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mi">0</code> <code class="p">{</code>
<code class="linenos"> 9 </code>		<code class="k">for</code> <code class="n">i</code><code class="p">,</code> <code class="n">addr</code> <code class="o">:=</code> <code class="nb">range</code> <code class="n">address</code> <code class="p">{</code>
<code class="linenos">10 </code>			<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"</code><code class="si">%d</code><code class="s2">: </code><code class="si">%s</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">i</code><code class="o">+</code><code class="mi">1</code><code class="p">,</code> <code class="n">addr</code><code class="p">)</code>
<code class="linenos">11 </code>		<code class="p">}</code>
<code class="linenos">12 </code>	<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
<code class="linenos">13 </code>		<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"No address data supplied"</code><code class="p">)</code>
<code class="linenos">14 </code>	<code class="p">}</code>
<code class="linenos">15 </code><code class="p">}</code>
<code class="linenos">16 </code>
<code class="linenos">17 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">18 </code>	<code class="o">//</code> <code class="n">single</code> <code class="n">argument</code>
<code class="linenos">19 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"Single Argument"</code><code class="p">)</code>
<code class="linenos">20 </code>	<code class="n">myVariadicFunc</code><code class="p">(</code><code class="s2">"Joe Bloggs"</code><code class="p">,</code> <code class="s2">"Address 1"</code><code class="p">)</code>
<code class="linenos">21 </code>
<code class="linenos">22 </code>	<code class="o">//</code> <code class="n">multiple</code> <code class="n">arguments</code>
<code class="linenos">23 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"</code><code class="se">\n</code><code class="s2">Multiple Arguments"</code><code class="p">)</code>
<code class="linenos">24 </code>	<code class="n">myVariadicFunc</code><code class="p">(</code><code class="s2">"Joe Bloggs"</code><code class="p">,</code> <code class="s2">"Address 1"</code><code class="p">,</code> <code class="s2">"Address 2"</code><code class="p">,</code> <code class="s2">"Address 3"</code><code class="p">)</code>
<code class="linenos">25 </code>
<code class="linenos">26 </code>	<code class="o">//</code> <code class="n">no</code> <code class="n">argument</code>
<code class="linenos">27 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"</code><code class="se">\n</code><code class="s2">No argument"</code><code class="p">)</code>
<code class="linenos">28 </code>	<code class="n">myVariadicFunc</code><code class="p">(</code><code class="s2">"Joe Bloggs"</code><code class="p">)</code>
<code class="linenos">29 </code>
<code class="linenos">30 </code>	<code class="o">//</code> <code class="n">passing</code> <code class="n">a</code> <code class="n">pre</code><code class="o">-</code><code class="n">built</code> <code class="nb">slice</code><code class="p">,</code> <code class="n">note</code> <code class="n">the</code> <code class="n">trailing</code> <code class="n">spread</code> <code class="n">operator</code>
<code class="linenos">31 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"</code><code class="se">\n</code><code class="s2">Passing a slice as a variadic argument"</code><code class="p">)</code>
<code class="linenos">32 </code>	<code class="n">addresses</code> <code class="o">:=</code> <code class="p">[]</code><code class="n">string</code><code class="p">{</code><code class="s2">"Address 1"</code><code class="p">,</code> <code class="s2">"Address 2"</code><code class="p">}</code>
<code class="linenos">33 </code>	<code class="n">myVariadicFunc</code><code class="p">(</code><code class="s2">"Joe Bloggs"</code><code class="p">,</code> <code class="n">addresses</code><code class="o">...</code><code class="p">)</code>
<code class="linenos">34 </code><code class="p">}</code>
<code class="linenos">35 </code>
<code class="linenos">36 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">NPutwf2aF4l</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code>Single Argument
<code class="linenos"> 2 </code>Hello Joe Bloggs!
<code class="linenos"> 3 </code>Addresses:
<code class="linenos"> 4 </code><code class="m">1</code>: Address <code class="m">1</code>
<code class="linenos"> 5 </code>
<code class="linenos"> 6 </code>Multiple Arguments
<code class="linenos"> 7 </code>Hello Joe Bloggs!
<code class="linenos"> 8 </code>Addresses:
<code class="linenos"> 9 </code><code class="m">1</code>: Address <code class="m">1</code>
<code class="linenos">10 </code><code class="m">2</code>: Address <code class="m">2</code>
<code class="linenos">11 </code><code class="m">3</code>: Address <code class="m">3</code>
<code class="linenos">12 </code>
<code class="linenos">13 </code>No argument
<code class="linenos">14 </code>Hello Joe Bloggs!
<code class="linenos">15 </code>Addresses:
<code class="linenos">16 </code>No address data supplied
<code class="linenos">17 </code>
<code class="linenos">18 </code>Passing a slice as a variadic argument
<code class="linenos">19 </code>Hello Joe Bloggs!
<code class="linenos">20 </code>Addresses:
<code class="linenos">21 </code><code class="m">1</code>: Address <code class="m">1</code>
<code class="linenos">22 </code><code class="m">2</code>: Address <code class="m">2</code>
<code class="linenos">23 </code>
<code class="linenos">24 </code>Program exited.
</pre></div>

</figure>


<h3 id="leanpub-auto-multiple-return-values" class="subsection">9.1.3 Multiple return values</h3>

<p>Another feature not present in many other programming languages is support for multiple function return values. </p>

<p>Typically, we’ll take advantage of this by using two return values in our functions, usually to pass an error value, or boolean value (to denote success or failure), in addition to the value we are interested in. </p>

<p>While the flexibilty to return more than two values <i>is</i> often useful, there’s a balance to be found. If the number of values we want from a function goes beyond three, it could mean our API would benefit from having those values as fields on a struct, or keys in a map. This way we could use a single value to return virtually unlimited data without complicating our codebase. It’s also much easier to maintain.</p>

<aside class="information blurb">
    <p>I used three as the <i>standard</i> since I couldn’t find a function in the Go standard library with more than three return values. Of course, there are no hard rules here, but, as Go developers, we should always consider the readability of our code.</p>

</aside>

<p>When using multiple returns we must comma delimit them and enclose the group in brackets. For example, here is the signature for <code>Split()</code> from the standard library <i>strings</i> package.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code><code class="k">func</code> <code class="n">Split</code><code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">sep</code> <code class="n">string</code><code class="p">)</code> <code class="p">(</code><code class="n">string</code><code class="p">,</code> <code class="n">string</code><code class="p">,</code> <code class="nb nb-Type">bool</code><code class="p">){}</code>
</pre></div>

</figure>


<h3 id="leanpub-auto-function-return-styles" class="subsection">9.1.4 Function return styles</h3>

<p>Functions can use <i>either</i> of two return styles, <i>Anonymous</i> or <i>Named</i> return parameters.  We can’t mix styles within the same function.</p>

<p>We saw an example of anonymous return parameters just above in the <code>Split()</code> function signature. That same signature using named return parameters could look like this.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code><code class="k">func</code> <code class="n">Split</code><code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">sep</code> <code class="n">string</code><code class="p">)</code> <code class="p">(</code><code class="n">param1</code><code class="p">,</code> <code class="n">param2</code> <code class="n">string</code><code class="p">,</code> <code class="n">param3</code> <code class="nb nb-Type">bool</code><code class="p">){}</code>
</pre></div>

</figure>


<p>When using named return parameters, there is no need to return the parameters explicitly. A simple <code>return</code> statemement, referred to as a <i>naked</i> return, is sufficient.  Note also that we don’t need to declare the variables explicitly in the function body, in the same way that we don’t need to declared the input parameters in the function body. The return body of the function, performs the declaration and intialisation.</p>

<p>An example will make this much clearer.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 85 - Anonymous and named return parameters</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code><code class="p">)</code>
<code class="linenos"> 6 </code>
<code class="linenos"> 7 </code><code class="n">func</code> <code class="n">anonymousReturns</code><code class="p">(</code><code class="n">firstname</code><code class="p">,</code> <code class="n">lastname</code> <code class="n">string</code><code class="p">)</code> <code class="n">string</code> <code class="p">{</code>
<code class="linenos"> 8 </code>	<code class="k">return</code> <code class="n">fmt</code><code class="o">.</code><code class="n">Sprintf</code><code class="p">(</code><code class="s2">"</code><code class="si">%s</code><code class="s2"> </code><code class="si">%s</code><code class="s2">"</code><code class="p">,</code> <code class="n">firstname</code><code class="p">,</code> <code class="n">lastname</code><code class="p">)</code>
<code class="linenos"> 9 </code><code class="p">}</code>
<code class="linenos">10 </code>
<code class="linenos">11 </code><code class="n">func</code> <code class="n">namedReturns</code><code class="p">(</code><code class="n">firstname</code><code class="p">,</code> <code class="n">lastname</code> <code class="n">string</code><code class="p">)</code> <code class="p">(</code><code class="n">fullname</code> <code class="n">string</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">12 </code>	<code class="n">fullname</code> <code class="o">=</code> <code class="n">fmt</code><code class="o">.</code><code class="n">Sprintf</code><code class="p">(</code><code class="s2">"</code><code class="si">%s</code><code class="s2"> </code><code class="si">%s</code><code class="s2">"</code><code class="p">,</code> <code class="n">firstname</code><code class="p">,</code> <code class="n">lastname</code><code class="p">)</code>
<code class="linenos">13 </code>	<code class="k">return</code>
<code class="linenos">14 </code><code class="p">}</code>
<code class="linenos">15 </code>
<code class="linenos">16 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">17 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">anonymousReturns</code><code class="p">(</code><code class="s2">"Joe"</code><code class="p">,</code> <code class="s2">"Bloggs"</code><code class="p">))</code>
<code class="linenos">18 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">namedReturns</code><code class="p">(</code><code class="s2">"Joe"</code><code class="p">,</code> <code class="s2">"Bloggs"</code><code class="p">))</code>
<code class="linenos">19 </code><code class="p">}</code>
<code class="linenos">20 </code>
<code class="linenos">21 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">RdVlD9CwJS4</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>Joe Bloggs
<code class="linenos">2 </code>Joe Bloggs
<code class="linenos">3 </code>
<code class="linenos">4 </code>Program exited.
</pre></div>

</figure>


<p>We have two simple functions, the first uses anonymous return parameters in the signature, the style we’ve used in all the examples up to this point.</p>

<p>The second function employs named return parameters.  Observe the <i>naked</i> return statement. Observe also, that we make an assignment to <code>fullname</code>, we’re not actually declaring it.  Try replacing the <code>=</code> with the shortform to declare/initialise it <code>:=</code> then run the example again.</p>

<p>The compiler complains that there are no new variables, since <code>fullname</code> was declared in the function signature.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>./prog.go:12:11: no new variables on left side of :<code class="o">=</code>
<code class="linenos">2 </code>
<code class="linenos">3 </code>Go build failed.
</pre></div>

</figure>


<p>The style you choose to adopt is largely a matter of preference.  For larger functions with multiple return values, one can argue that named return parameters make the function body less clear and harder to read.</p>

<p>The counter to that is that the function signature itself is much more explicit. Developers have a clearer idea of what a function will give them back when named returns are used. With anonymous return parameters, the developer is presented with a list of types and they will need to inspect the function body to ascertain the usefulness of the values returned for those types.</p>

<p>The other consideration is the potential for bugs and confusion.</p>

<p>Because named return parameters are declared in the signature, and because they are initialised to their zero value, they satisfy the function return automatically even if they are never assigned.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 86 - Bug risk or not?</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code><code class="p">)</code>
<code class="linenos"> 6 </code>
<code class="linenos"> 7 </code><code class="n">func</code> <code class="n">anonymousReturns</code><code class="p">()</code> <code class="p">(</code><code class="n">string</code><code class="p">,</code> <code class="n">string</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos"> 8 </code>	<code class="n">var</code> <code class="n">firstname</code><code class="p">,</code> <code class="n">lastname</code> <code class="n">string</code> <code class="o">//</code> <code class="n">we</code> <code class="n">had</code> <code class="n">to</code> <code class="n">declare</code> <code class="n">lastname</code>
<code class="linenos"> 9 </code>	<code class="n">firstname</code> <code class="o">=</code> <code class="s2">"Joe"</code>
<code class="linenos">10 </code>	<code class="k">return</code> <code class="n">firstname</code><code class="p">,</code> <code class="n">lastname</code> <code class="o">//</code> <code class="n">we</code> <code class="n">had</code> <code class="n">to</code> <code class="k">return</code> <code class="n">lastname</code>
<code class="linenos">11 </code><code class="p">}</code>
<code class="linenos">12 </code>
<code class="linenos">13 </code><code class="n">func</code> <code class="n">namedReturns</code><code class="p">()</code> <code class="p">(</code><code class="n">firstname</code><code class="p">,</code> <code class="n">lastname</code> <code class="n">string</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">14 </code>	<code class="n">firstname</code> <code class="o">=</code> <code class="s2">"Joe"</code>
<code class="linenos">15 </code>	<code class="k">return</code> <code class="o">//</code> <code class="n">did</code> <code class="n">we</code> <code class="n">forget</code> <code class="n">the</code> <code class="n">signature</code> <code class="n">also</code> <code class="n">includes</code> <code class="err">`</code><code class="n">lastname</code><code class="err">`?</code>
<code class="linenos">16 </code><code class="p">}</code>
<code class="linenos">17 </code>
<code class="linenos">18 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">19 </code>	<code class="n">mask</code> <code class="o">:=</code> <code class="s2">"firstname: '</code><code class="si">%s</code><code class="s2">', lastname: '</code><code class="si">%s</code><code class="s2">'</code><code class="se">\n</code><code class="s2">"</code>
<code class="linenos">20 </code>	<code class="n">f1</code><code class="p">,</code> <code class="n">l1</code> <code class="o">:=</code> <code class="n">anonymousReturns</code><code class="p">()</code>
<code class="linenos">21 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="n">mask</code><code class="p">,</code> <code class="n">f1</code><code class="p">,</code> <code class="n">l1</code><code class="p">)</code>
<code class="linenos">22 </code>	<code class="n">f2</code><code class="p">,</code> <code class="n">l2</code> <code class="o">:=</code> <code class="n">namedReturns</code><code class="p">()</code>
<code class="linenos">23 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="n">mask</code><code class="p">,</code> <code class="n">f2</code><code class="p">,</code> <code class="n">l2</code><code class="p">)</code>
<code class="linenos">24 </code><code class="p">}</code>
<code class="linenos">25 </code>
<code class="linenos">26 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">gHxfLdGgTaX</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>firstname: <code class="s1">'Joe'</code>, lastname: <code class="s1">''</code>
<code class="linenos">2 </code>firstname: <code class="s1">'Joe'</code>, lastname: <code class="s1">''</code>
<code class="linenos">3 </code>
<code class="linenos">4 </code>Program exited.
</pre></div>

</figure>


<p>Compare the two functions in previous example.  In the first, the <code>lastname</code> variable must be explictly created and explicitly returned by us. Yes, it could still be its zero value, but that would be down to us, it would be our mistake.</p>

<p>But, in the second function, we’ve not made an assignment either, and we don’t mention the <code>lastname</code> variable at all, not even in a comment, and nor does the naked return.</p>

<p>But, <code>lastname</code> is returned as its zero value and passed back up the call stack. That could well be ok, something we plan to come back to, but we might not have intended to do this. What if we’ve forgotten we added it to the function signature in the first place?</p>

<aside class="information blurb">
    <p>Edge case? Yes, probably, but that’s a mistake I’ve made myself. It’s especially easy to make when the function body is large, so the function signature isn’t in view to remind us. I’d suggest taking care when using named returns.  For most usecases anonymous return parameters will be a better choice, but that’s only <i>in my opinion</i>.</p>

</aside>

<h3 id="leanpub-auto-functions-are-a-type" class="subsection">9.1.5 Functions are a type</h3>

<p>Functions are themselves a type. Values of the type can be created and used just like any Go type. This means functions can be assigned to variables, passed as arguments to other functions, and returned as values from functions.</p>

<p>We call functions which accept and return other functions, <i>higher-order functions</i> and they offer a high degree of flexibility in how we arrange our code. Functions which accept other functions are also known as <i>callbacks</i>.</p>

<p>The example below shows a simple callback type function, we can implement as many different formatting functions as we wish. Providing they are of the type, of <code>func(string)string</code>, we can use them in <code>Formatter()</code>.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 87 - Callback style functions</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code>	<code class="s2">"strings"</code>
<code class="linenos"> 6 </code><code class="p">)</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="o">//</code> <code class="n">Formatter</code> <code class="n">accepts</code> <code class="nb">any</code> <code class="n">func</code> <code class="n">of</code> <code class="nb">type</code> <code class="n">func</code> <code class="p">(</code><code class="n">string</code><code class="p">)</code> <code class="n">string</code>
<code class="linenos"> 9 </code><code class="n">func</code> <code class="n">Formatter</code><code class="p">(</code><code class="nb">str</code> <code class="n">string</code><code class="p">,</code> <code class="nb">format</code> <code class="n">func</code><code class="p">(</code><code class="ow">in</code> <code class="n">string</code><code class="p">)</code> <code class="n">string</code><code class="p">)</code> <code class="n">string</code> <code class="p">{</code>
<code class="linenos">10 </code>	<code class="k">return</code> <code class="nb">format</code><code class="p">(</code><code class="nb">str</code><code class="p">)</code>
<code class="linenos">11 </code><code class="p">}</code>
<code class="linenos">12 </code>
<code class="linenos">13 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">14 </code>	<code class="n">upper</code> <code class="o">:=</code> <code class="n">func</code><code class="p">(</code><code class="ow">in</code> <code class="n">string</code><code class="p">)</code> <code class="n">string</code> <code class="p">{</code>
<code class="linenos">15 </code>		<code class="k">return</code> <code class="n">strings</code><code class="o">.</code><code class="n">ToUpper</code><code class="p">(</code><code class="ow">in</code><code class="p">)</code>
<code class="linenos">16 </code>	<code class="p">}</code>
<code class="linenos">17 </code>
<code class="linenos">18 </code>	<code class="n">lower</code> <code class="o">:=</code> <code class="n">func</code><code class="p">(</code><code class="ow">in</code> <code class="n">string</code><code class="p">)</code> <code class="n">string</code> <code class="p">{</code>
<code class="linenos">19 </code>		<code class="k">return</code> <code class="n">strings</code><code class="o">.</code><code class="n">ToLower</code><code class="p">(</code><code class="ow">in</code><code class="p">)</code>
<code class="linenos">20 </code>	<code class="p">}</code>
<code class="linenos">21 </code>
<code class="linenos">22 </code>	<code class="n">myText</code> <code class="o">:=</code> <code class="s2">"SomE rANDOm text TO foRmat"</code>
<code class="linenos">23 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">Formatter</code><code class="p">(</code><code class="n">myText</code><code class="p">,</code> <code class="n">upper</code><code class="p">))</code>
<code class="linenos">24 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">Formatter</code><code class="p">(</code><code class="n">myText</code><code class="p">,</code> <code class="n">lower</code><code class="p">))</code>
<code class="linenos">25 </code><code class="p">}</code>
<code class="linenos">26 </code>
<code class="linenos">27 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">KXSxlwcWJB4</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>SOME RANDOM TEXT TO FORMAT
<code class="linenos">2 </code>some random text to format
<code class="linenos">3 </code>
<code class="linenos">4 </code>Program exited.
</pre></div>

</figure>


<p>We should also mention <i>closures</i>. A <i>closure</i> is a function that remembers the values of the variables from the place where it was created, as if it was bound to them. Nothing here is unique to Go, but closures can be useful when we want to use a function in a different place, but we still want it to have access to the variables it needs.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 88 - Closure functions</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"fmt"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="n">x</code> <code class="o">:=</code> <code class="mi">10</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code>	<code class="n">increment</code> <code class="o">:=</code> <code class="n">func</code><code class="p">()</code> <code class="nb">int</code> <code class="p">{</code>
<code class="linenos"> 9 </code>		<code class="n">x</code><code class="o">++</code>
<code class="linenos">10 </code>		<code class="k">return</code> <code class="n">x</code>
<code class="linenos">11 </code>	<code class="p">}</code>
<code class="linenos">12 </code>
<code class="linenos">13 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">increment</code><code class="p">())</code> <code class="o">//</code> <code class="n">prints</code> <code class="mi">11</code>
<code class="linenos">14 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">increment</code><code class="p">())</code> <code class="o">//</code> <code class="n">prints</code> <code class="mi">12</code>
<code class="linenos">15 </code><code class="p">}</code>
<code class="linenos">16 </code>
<code class="linenos">17 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">x8XnvAM6O9C</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code><code class="m">11</code>
<code class="linenos">2 </code><code class="m">12</code>
<code class="linenos">3 </code>
<code class="linenos">4 </code>Program exited.
</pre></div>

</figure>


<p>Observe, in the example above, that the <code>increment</code> function has access to the <code>x</code> variable even though it is defined outside of the function. This is possible because <code>increment</code> is a closure.</p>

<h3 id="leanpub-auto-pointer-or-value-returns" class="subsection">9.1.5 Pointer or value returns</h3>

<p>When writing functions, we need to decide whether to return values or pointers. The decision can have an impact on both memory use and how memory is managed. This shouldn’t be an initial consideration, as always we should prioritise correctness and maintainability until we can verify we have some performance issues.</p>

<p>The choice between returning a value or a pointer from a function should depend on the intended use case. If we want to create a single value of something in a function and share it throughout our program, we should return a pointer to that value. On the other hand, if we only need to use the value within the function and do not need to mutate anything we share up the call stack, it may be more efficient to return a copy of the value instead of a pointer.</p>

<p>A good example of when it is beneficial to return a pointer is when creating a database connection. By returning a pointer, multiple parts of the program can use the same connection simultaneously, rather than each part creating its own connection. This can help to improve the efficiency of the program by reducing the number of connections that need to be created and managed.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 89 - Pointer return for database connection</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"fmt"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="nb">type</code> <code class="n">Database</code> <code class="n">struct</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="n">ConnString</code> <code class="n">string</code>
<code class="linenos"> 7 </code><code class="p">}</code>
<code class="linenos"> 8 </code>
<code class="linenos"> 9 </code><code class="o">//</code> <code class="n">NewDatabase</code> <code class="ow">is</code> <code class="n">a</code> <code class="n">naive</code> <code class="n">factory</code> <code class="n">to</code> <code class="n">create</code> <code class="n">a</code> <code class="n">database</code> <code class="n">connection</code>
<code class="linenos">10 </code><code class="o">//</code> <code class="n">it</code> <code class="n">returns</code> <code class="n">a</code> <code class="n">pointer</code> <code class="n">to</code> <code class="n">share</code> <code class="n">the</code> <code class="n">address</code> <code class="n">of</code> <code class="n">the</code> <code class="n">connection</code> <code class="n">info</code>
<code class="linenos">11 </code><code class="n">func</code> <code class="n">NewDatabase</code><code class="p">(</code><code class="n">server</code><code class="p">,</code> <code class="n">username</code><code class="p">,</code> <code class="n">password</code> <code class="n">string</code><code class="p">)</code> <code class="o">*</code><code class="n">Database</code> <code class="p">{</code>
<code class="linenos">12 </code>	<code class="k">if</code> <code class="n">db</code> <code class="o">!=</code> <code class="n">nil</code> <code class="p">{</code>
<code class="linenos">13 </code>		<code class="k">return</code> <code class="n">db</code>
<code class="linenos">14 </code>	<code class="p">}</code>
<code class="linenos">15 </code>	<code class="n">connString</code> <code class="o">:=</code> <code class="n">fmt</code><code class="o">.</code><code class="n">Sprintf</code><code class="p">(</code><code class="s2">"</code><code class="si">%s</code><code class="s2">@</code><code class="si">%s</code><code class="s2">:</code><code class="si">%s</code><code class="s2">"</code><code class="p">,</code> <code class="n">username</code><code class="p">,</code> <code class="n">server</code><code class="p">,</code> <code class="n">password</code><code class="p">)</code>
<code class="linenos">16 </code>	<code class="k">return</code> <code class="o">&amp;</code><code class="n">Database</code><code class="p">{</code><code class="n">connString</code><code class="p">}</code>
<code class="linenos">17 </code><code class="p">}</code>
<code class="linenos">18 </code>
<code class="linenos">19 </code><code class="n">var</code> <code class="n">db</code> <code class="o">*</code><code class="n">Database</code>
<code class="linenos">20 </code>
<code class="linenos">21 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">22 </code>	<code class="n">db</code> <code class="o">=</code> <code class="n">NewDatabase</code><code class="p">(</code><code class="s2">"localhost"</code><code class="p">,</code> <code class="s2">"joeblogs"</code><code class="p">,</code> <code class="s2">"password"</code><code class="p">)</code>
<code class="linenos">23 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"Connection String: %+v</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">db</code><code class="p">)</code>
<code class="linenos">24 </code><code class="p">}</code>
<code class="linenos">25 </code>
<code class="linenos">26 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="mi">0</code><code class="n">afFBh0GaFG</code>
</pre></div>

</figure>


<p>Generally, returning a pointer forces the compiler to allocate that variable to slower memory, and we’ll talk more about this in the next section on <i>memory management</i>.</p>

<h2 id="leanpub-auto-memory-management" class="section">9.2 Memory management</h2>

<p>Go performs memory management on our behalf. The compiler chooses where to put the values our program creates - on either the <i>stack</i> or the <i>heap</i> - when compiling our program, and the garbage collector manages heap memory during program execution.</p>

<p>The <i>stack</i> is a region of memory used for storing local variables and function parameters. The total size of the stack is limited in size but stack memory offers fast access. Each function call or goroutine starts with an initial stack of 2KB dedicated to it. This may be grown as required. </p>

<p>The <i>heap</i> is a region of memory used for dynamically-allocated objects at runtime, or variables the compiler decides to put there and not on the stack. Heap memory is shared and not bound to any one function. There’s more heap memory available than stack memory, but it’s also slower to access. The process of garbage collection on the heap adds further overhead.</p>

<p>We refer to variables placed on the heap as <i>allocations</i>. As a rule of thumb, the fewer allocations our programs make, the better. An allocation represents data in slower access memory, which has to be cleaned up by the garbage collector.</p>

<aside class="information blurb">
    <p>It is not our intention to eliminate allocations. That’s often impossible. For example, the simple act of printing using <code>fmt.Println()</code> may create allocations. The compiler treats this function from the standard library, like any custom function. If it cannot be sure what the function does with the argument it receives, it cannot determine the lifetime of the value. Contrast that with the Go’s built-in <code>println()</code> function. The compiler <i>always</i> knows that <code>println()</code> does nothing else with the passed argument, so can leave the data on the stack, and no allocations are made.</p>

</aside>

<p>The goal is to minimise allocations, especially in functions that are called frequently. Indeed the compiler will make many optimisations at compilation time, one of which is <i>inlining</i>, where code in function bodies is pulled into the main function eliminating calls and returns, and in many cases reducing allocations in the process.</p>

<p>The compiler uses a process known as <i>escape analysis</i> to determine what can be <i>inlined</i>, it uses the same process to determine whether a value can sit on the stack or must be placed on the heap. The compiler will make an allocation for multiple reasons. Wherever an address is shared, rather than a copy of the value, the compiler will make an allocation if it cannot be certain it is not used beyond the scope of the current function’s lifetime. </p>

<p>As a <i>general</i> rule passing values around rather than pointers allows us to reduce allocations.</p>

<p>We can observe the escape analysis performed by the compiler, and we’ll do this shortly.</p>

<h3 id="leanpub-auto-garbage-collection" class="subsection">9.2.3 Garbage collection</h3>

<p>Heap memory management is the responsibility of the garbage collector which will deallocate memory when it can no longer find any references to it. The garbage collector is packaged with every Go program.</p>

<p>At runtime, the garbage collection process has a cost. Known as the GC pause, historically it was a <i>stop-the-world</i> type operation in which all goroutines were paused while heap memory was deallocated. In most applications this pause was imperceptible, but in high-throughput, high-performance applications it could cause performance issues such as bottlenecks and throttling.</p>

<p>In modern versions of Go, the garbage collection process is more sophisticated, it does not need to suspend all goroutines at the same time and generally completes much faster.</p>

<h3 id="leanpub-auto-observing-compiler-escape-analysis" class="subsection">9.2.4 Observing compiler escape analysis</h3>

<p>So, we have some basic criteria which may indicate when the compiler will use the heap and not the stack, but, the fact is, we will not be able to read a complex piece of code and reliably determine which type of memory will be chosen and how many allocations will result.</p>

<p>Furthermore, the algorithm, or ruleset, which decides what is stack memory and what is heap is constantly being refined. So, rather than guess, it’s better that we undertake the same escape analysis that the compiler performs during compilation. </p>

<p>The snippet below shows how we use the <code>-gcflags "-m"</code> flag to view escape analysis output when running or building a program.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code><code class="c1">## build</code>
<code class="linenos">2 </code>go build -gcflags<code class="o">=</code><code class="s2">"-m"</code>
<code class="linenos">3 </code>
<code class="linenos">4 </code><code class="c1">## run</code>
<code class="linenos">5 </code>go run -gcflags<code class="o">=</code><code class="s2">"-m"</code> ./main.go
</pre></div>

</figure>


<aside class="information blurb">
    <p>Unfortunately, it’s not possible to pass build flags when we run code on the Go Playground. To see the output from the following examples yourself, you’ll need to run the code in a local environment, or just follow the output included.</p>

</aside>

<p>Alongside escape analysis we can also use benchmarks, part of the testing suite we’ll cover later, to determine when allocations are made. So, for each example, we’ll create a benchmark file which we’ll be able to run with this command. </p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>go <code class="nb">test</code> -bench . -benchmen
</pre></div>

</figure>


<p>The command instructs the <i>go test</i> tool to run all benchmarks, and include benchmark metrics for memory in the output.</p>

<p>Benchmarks will tell us how many allocations a piece of code makes. Escape analysis lets us identify the specific lines of code which cause those allocations.</p>

<aside class="information blurb">
    <p>A word on inlining. We are not passing the <code>-l</code> flag which turns off inlining globally. Instead, we will use the <code>//go:noinline</code> compiler directive in our examples to prevent functions from being inlined. This is my preference, since the benchmarks will also run with inlining disabled without changing the benchmark command.</p>

</aside>

<p>The code shown below is used to generate the benchmark results. In a later chapter, we’ll cover benchmarking when we discuss <i>quality assurance</i>.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos">2 </code>
<code class="linenos">3 </code><code class="kn">import</code> <code class="s2">"testing"</code>
<code class="linenos">4 </code>
<code class="linenos">5 </code><code class="n">func</code> <code class="n">BenchmarkMain</code><code class="p">(</code><code class="n">b</code> <code class="o">*</code><code class="n">testing</code><code class="o">.</code><code class="n">B</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">6 </code>	<code class="k">for</code> <code class="n">i</code><code class="o">:=</code><code class="mi">0</code><code class="p">;</code> <code class="n">i</code><code class="o">&lt;</code> <code class="n">b</code><code class="o">.</code><code class="n">N</code><code class="p">;</code> <code class="n">i</code><code class="o">++</code> <code class="p">{</code>
<code class="linenos">7 </code>		<code class="n">main</code><code class="p">()</code>
<code class="linenos">8 </code>	<code class="p">}</code>
<code class="linenos">9 </code><code class="p">}</code>
</pre></div>

</figure>


<p>In this first example we’re not calling any of our own code, we’re simply using the standard library <code>fmt</code> package and the built-in <code>println()</code> function.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 90 - Escape analysis with benchmark</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"fmt"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="n">input1</code> <code class="o">:=</code> <code class="mi">1</code>
<code class="linenos"> 7 </code>	<code class="n">input2</code> <code class="o">:=</code> <code class="s2">"Joe Blogs"</code>
<code class="linenos"> 8 </code>
<code class="linenos"> 9 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">input1</code><code class="p">)</code>
<code class="linenos">10 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">input2</code><code class="p">)</code>
<code class="linenos">11 </code>
<code class="linenos">12 </code>	<code class="o">//</code><code class="n">println</code><code class="p">(</code><code class="n">input1</code><code class="p">)</code>
<code class="linenos">13 </code>	<code class="o">//</code><code class="n">println</code><code class="p">(</code><code class="n">input2</code><code class="p">)</code>
<code class="linenos">14 </code><code class="p">}</code>
<code class="linenos">15 </code>
<code class="linenos">16 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">rqTcK20eVqV</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>// go run -gcflags<code class="o">=</code><code class="s2">"-m"</code> ./main.go
<code class="linenos">2 </code>./main.go:11:13: input1 escapes to heap
<code class="linenos">3 </code>./main.go:12:13: input2 escapes to heap
<code class="linenos">4 </code>
<code class="linenos">5 </code>// go <code class="nb">test</code> -bench . -benchmen
<code class="linenos">6 </code><code class="m">51032</code>             <code class="m">22628</code> ns/op              <code class="m">16</code> B/op          <code class="m">1</code> allocs/op
</pre></div>

</figure>


<p>The escape analysis output is abbreviated. We are interested in messages which say <code>x escapes to heap</code> or <code>moved to heap: x</code>.</p>

<p>If we see <code>x escapes to heap</code>, it means the value is leaving the functions local scope. It <i>often</i> means that the compiler will store the value on the heap, but not always. </p>

<p>If we see <code>moved to heap: x</code>, that’s a clear message that the compiler has decided the value needs to be allocated on the heap, and there will be an allocation associated with that decision.</p>

<p>Looking at the above example output, we may expect the compiler to have made two allocations, but looking at the benchmark output, it only made one, see <code>1 allocs/op</code> on the right of the output. The allocation is made on the string value.  The compiler does not know that the function does not reslice the string’s backing data so it puts it on the heap. Comment the code appropriately and run it again to see.</p>

<aside class="information blurb">
    <p>That’s the first takeaway. Escape analysis and benchmarking are worth using together, and <i>escapes to heap</i> does not always mean an allocation was made.</p>

</aside>

<p>Finally, alter the code to use the <code>println()</code> built-in function, and no allocations are made. The compiler knows exactly what this function does with the passed argument, so places everything on the stack.</p>

<p>In the next example, we create several functions of our own and use escape analysis with benchmarking to understand the allocations which may result.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 91 - Escape analysis on function returns</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="o">//</code> <code class="n">go</code> <code class="n">run</code> <code class="o">-</code><code class="n">gcflags</code><code class="o">=</code><code class="s2">"-m"</code> <code class="o">./</code><code class="n">main</code><code class="o">.</code><code class="n">go</code>
<code class="linenos"> 2 </code><code class="o">//</code> <code class="n">go</code> <code class="n">test</code> <code class="o">-</code><code class="n">bench</code> <code class="o">.</code> <code class="o">-</code><code class="n">benchmem</code>
<code class="linenos"> 3 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="n">type</code> <code class="n">Customer</code> <code class="n">struct</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="n">Name</code> <code class="n">string</code>
<code class="linenos"> 7 </code>	<code class="n">Email</code> <code class="n">string</code>
<code class="linenos"> 8 </code>	<code class="n">Age</code> <code class="nb nb-Type">int</code>
<code class="linenos"> 9 </code><code class="p">}</code>
<code class="linenos">10 </code>
<code class="linenos">11 </code><code class="o">//</code><code class="n">go</code><code class="p">:</code><code class="n">noinline</code>
<code class="linenos">12 </code><code class="k">func</code> <code class="n">NewCustomer</code><code class="p">(</code><code class="n">name</code> <code class="n">string</code><code class="p">)</code> <code class="n">Customer</code> <code class="p">{</code>
<code class="linenos">13 </code>	<code class="n">cust</code> <code class="p">:</code><code class="o">=</code> <code class="n">Customer</code><code class="p">{</code><code class="n">Name</code><code class="p">:</code><code class="n">name</code><code class="p">}</code>
<code class="linenos">14 </code>	<code class="k">return</code> <code class="n">cust</code>
<code class="linenos">15 </code><code class="p">}</code>
<code class="linenos">16 </code>
<code class="linenos">17 </code><code class="o">//</code><code class="n">go</code><code class="p">:</code><code class="n">noinline</code>
<code class="linenos">18 </code><code class="k">func</code> <code class="n">NewCustomer2</code><code class="p">(</code><code class="n">name</code> <code class="n">string</code><code class="p">)</code> <code class="o">*</code><code class="n">Customer</code> <code class="p">{</code>
<code class="linenos">19 </code>	<code class="n">cust2</code> <code class="p">:</code><code class="o">=</code> <code class="n">Customer</code><code class="p">{</code><code class="n">Name</code><code class="p">:</code><code class="n">name</code><code class="p">}</code>
<code class="linenos">20 </code>	<code class="k">return</code> <code class="o">&amp;</code><code class="n">cust2</code>
<code class="linenos">21 </code><code class="p">}</code>
<code class="linenos">22 </code>
<code class="linenos">23 </code><code class="o">//</code><code class="n">go</code><code class="p">:</code><code class="n">noinline</code>
<code class="linenos">24 </code><code class="k">func</code> <code class="n">NewCustomer3</code><code class="p">(</code><code class="n">name</code> <code class="n">string</code><code class="p">)</code> <code class="o">*</code><code class="n">Customer</code> <code class="p">{</code>
<code class="linenos">25 </code>	<code class="k">return</code> <code class="o">&amp;</code><code class="n">Customer</code><code class="p">{</code><code class="n">Name</code><code class="p">:</code><code class="n">name</code><code class="p">}</code>
<code class="linenos">26 </code><code class="p">}</code>
<code class="linenos">27 </code>
<code class="linenos">28 </code><code class="k">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">29 </code>	<code class="n">input</code> <code class="p">:</code><code class="o">=</code> <code class="s2">"Joe Blogs"</code>
<code class="linenos">30 </code>	<code class="n">_</code> <code class="o">=</code> <code class="n">NewCustomer</code><code class="p">(</code><code class="n">input</code><code class="p">)</code>
<code class="linenos">31 </code>	<code class="n">_</code> <code class="o">=</code> <code class="n">NewCustomer2</code><code class="p">(</code><code class="n">input</code><code class="p">)</code>
<code class="linenos">32 </code>	<code class="n">_</code> <code class="o">=</code> <code class="n">NewCustomer3</code><code class="p">(</code><code class="n">input</code><code class="p">)</code>
<code class="linenos">33 </code><code class="p">}</code>
<code class="linenos">34 </code>
<code class="linenos">35 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">rC5x05MpKP5</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>// go run -gcflags<code class="o">=</code><code class="s2">"-m"</code> ./main.go
<code class="linenos">2 </code>./main.go:19:2: moved to heap: cust2
<code class="linenos">3 </code>./main.go:25:9: <code class="p">&amp;</code>Customer<code class="o">{</code>...<code class="o">}</code> escapes to heap
<code class="linenos">4 </code>
<code class="linenos">5 </code>// go <code class="nb">test</code> -bench . -benchmen
<code class="linenos">6 </code><code class="m">15239967</code>                <code class="m">66</code>.54 ns/op           <code class="m">96</code> B/op          <code class="m">2</code> allocs/op
</pre></div>

</figure>


<p>In this example, we have three very similar <i>factory</i> style functions which create and return a <code>Customer{}</code>, either as a value or as a pointer. </p>

<p>The first function returns a value, which is a copy of the value created inside the function. The compiler knows everything can sit on the stack - when the function is finished that copy does not reference anything inside the function. There are no allocations made.</p>

<p>The second function creates a <code>Customer{}</code> value <code>cust2</code>, but then its address is taken and a pointer is returned. The compiler can’t know how this value will be accessed and used later and it lives beyond the function’s lifetime, so this value can’t sit on the stack, it must be <i>moved to the heap</i>.</p>

<p>The final function is similar to the last, except an address is immediately taken and returned. Escape analysis indicates this <i>escapes to the heap</i> indicating there may be an allocation, and the benchmark results confirm that an allocation was made.</p>

<h2 id="leanpub-auto-using-receivers-with-custom-types" class="section">9.3 Using receivers with custom types</h2>

<p>Let’s dig deeper into receivers.</p>

<p>Receivers are essentially a different kind of function. All the learning we’ve acquired in the earlier section on <code>developing with functions</code> is valid here too. However, unlike functions, receivers have a unique characteristic that makes them similar to methods in OOP.</p>

<p>Unlike methods which exist on a class, receivers can be bound to any user-defined type, which allows the receiver to access the value of that type. For example, if a receiver is bound to a custom struct, it can access the fields of the struct just like a method can access the properties of a class. </p>

<p>Receivers are useful when writing functionality intended to work with a value of a specific type, for example, <i>getter</i> and <i>setter</i> routines which read the value and can change the value. </p>

<p>Because they can be bound to a custom type, receivers have internal access to the value of that type. This avoids the <i>value</i> having to be passed into the receiver as arguments, which would be necessary if we chose to use functions to perform the <i>getter</i> and <i>setter</i> operations mentioned above. </p>

<p>Similarly, because the access is internal, any mutation of the value is also performed inside the receiver and not by return values as would be the case with functions.</p>

<p>Receivers can either <i>receive</i> a copy of the value, which as you would expect can only be read, not mutated, or, they can receive a pointer to the value, which allows the receiver to mutate the value from within the receiver body.  These are known as <i>value receivers</i> and <i>pointer receivers</i> respectively. We covered <i>pointer</i> and <i>value</i> semantics in Chapter 6.</p>

<aside class="information blurb">
    <p>A <i>value receiver</i> gets a copy of the value on every call, which could be significant in size for large types. A <i>pointer receiver</i> uses less memory since only a copy of the memory address is passed into the receiver on every call. Consequently, for very large types, there can be a case for using <i>pointer receivers</i> even if the value will only be read and not mutated.</p>

</aside>

<p>In the same way receivers have access to the value, they can also access other receivers bound to the same type, which means we can call other receivers from within receivers.</p>

<p>In the next example, we show a value and pointer receiver implementation on the same <code>customer</code> struct. Mixing them in this way is not considered good practice - we’re doing it here to keep the example concise.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 92 - Value and pointer receivers</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"fmt"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="nb">type</code> <code class="n">customer</code> <code class="n">struct</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="n">Name</code> <code class="n">string</code>
<code class="linenos"> 7 </code><code class="p">}</code>
<code class="linenos"> 8 </code>
<code class="linenos"> 9 </code><code class="o">//</code> <code class="n">UpdateName</code> <code class="ow">is</code> <code class="n">a</code> <code class="n">pointer</code> <code class="n">receiver</code>
<code class="linenos">10 </code><code class="n">func</code> <code class="p">(</code><code class="n">c</code> <code class="o">*</code><code class="n">customer</code><code class="p">)</code> <code class="n">UpdateName</code><code class="p">(</code><code class="n">newStr</code> <code class="n">string</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">11 </code>	<code class="n">c</code><code class="o">.</code><code class="n">Name</code> <code class="o">=</code> <code class="n">newStr</code>
<code class="linenos">12 </code><code class="p">}</code>
<code class="linenos">13 </code>
<code class="linenos">14 </code><code class="o">//</code> <code class="n">PrintName</code> <code class="ow">is</code> <code class="n">a</code> <code class="n">value</code> <code class="n">receiver</code>
<code class="linenos">15 </code><code class="n">func</code> <code class="p">(</code><code class="n">c</code> <code class="n">customer</code><code class="p">)</code> <code class="n">PrintName</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">16 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"This is reading the value: </code><code class="si">%s</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">c</code><code class="o">.</code><code class="n">Name</code><code class="p">)</code>
<code class="linenos">17 </code>    <code class="n">c</code><code class="o">.</code><code class="n">PrintLine</code><code class="p">()</code> <code class="o">//</code> <code class="n">calling</code> <code class="n">another</code> <code class="n">receiver</code>
<code class="linenos">18 </code><code class="p">}</code>
<code class="linenos">19 </code>
<code class="linenos">20 </code><code class="n">func</code> <code class="p">(</code><code class="n">customer</code><code class="p">)</code> <code class="n">PrintLine</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">21 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"-------------------------------------"</code><code class="p">)</code>
<code class="linenos">22 </code><code class="p">}</code>
<code class="linenos">23 </code>
<code class="linenos">24 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">25 </code>	<code class="n">var</code> <code class="n">cust</code> <code class="o">=</code> <code class="o">&amp;</code><code class="n">customer</code><code class="p">{</code><code class="s2">"Joe Blogs"</code><code class="p">}</code>
<code class="linenos">26 </code>
<code class="linenos">27 </code>	<code class="o">//</code> <code class="n">read</code> <code class="n">via</code> <code class="n">value</code> <code class="n">receiver</code>
<code class="linenos">28 </code>	<code class="n">cust</code><code class="o">.</code><code class="n">PrintName</code><code class="p">()</code>
<code class="linenos">29 </code>
<code class="linenos">30 </code>	<code class="o">//</code> <code class="n">update</code>
<code class="linenos">31 </code>	<code class="n">cust</code><code class="o">.</code><code class="n">UpdateName</code><code class="p">(</code><code class="s2">"Dave Blogs"</code><code class="p">)</code>
<code class="linenos">32 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"Updated string is value: </code><code class="si">%s</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">cust</code><code class="o">.</code><code class="n">Name</code><code class="p">)</code>
<code class="linenos">33 </code>	<code class="n">cust</code><code class="o">.</code><code class="n">PrintLine</code><code class="p">()</code>
<code class="linenos">34 </code><code class="p">}</code>
<code class="linenos">35 </code>
<code class="linenos">36 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">qTBFdsIDdCL</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>This is reading the value: Joe Blogs
<code class="linenos">2 </code>-------------------------------------
<code class="linenos">3 </code>Updated string is value: Dave Blogs
<code class="linenos">4 </code>-------------------------------------
<code class="linenos">5 </code>
<code class="linenos">6 </code>Program exited.
</pre></div>

</figure>


<aside class="information blurb">
    <p>The <code>Printline()</code> receiver makes no use of the <code>customer</code> value at all, so we have removed the variable accessor <code>c</code> to indicate this is the case. The only case for using a receiver rather than a function here is that in text editors with code completion, it will form part of the same prompt API as it is bound to the same <code>customer</code> type.</p>

</aside>

<p>Finally, a few <i>suggested</i> style rules when using receivers. The compiler will not enforce these rules, but they do help improve the consistency and clarity of our code.</p>

<p>If one or more of our receivers should mutate the value on which it is bound, then we need to use at least one <i>pointer receiver</i>, so should make all receivers bound to that type, a <i>pointer receiver</i>.</p>

<p>Conversely, if nothing mutates the value but only reads it, then we should bind only <i>value receivers</i> to the type, <b>unless</b> we are dealing with very large types and making copies of values would be very inefficient.</p>

<p>We should use a short variable to access to the value inside the receiver body. The context and scope are very clear. There is no need for semantic naming.</p>

<p>If a receiver neither reads nor mutates the value, we should remove the variable accessor entirely as a mechanism for communicating this. We may also consider using a simple function instead since there is no need for the receiver to be bound to a type it neither reads nor mutates.</p>

<h2 id="leanpub-auto-working-with-interfaces" class="section">9.4 Working with interfaces</h2>

<p>We’ve already discussed interfaces in Chapter 7 on <i>type</i>. Despite my intention, we covered many of the core points of learning back then.</p>

<p>In this section we’re going to quickly recap, and then look at some interface implementations of our own, demonstrating their value in building flexible, more extensible programs. We’re also going use interfaces to create mock representations of services which we can use in our testing.  We’ll try not to go too deep into testing itself at this stage. </p>

<h3 id="leanpub-auto-recapping" class="subsection">9.4.1 Recapping</h3>

<p>In Go, an interface is a set of receiver signatures. A value of an interface type can hold any value that implements those receivers. Interfaces are a way to specify the required behaviour of a type: if a type has the receivers specified by an interface, then it is said to implement that interface. It does not need to be explicitly stated in the code that it implements the interface.</p>

<p>The empty interface, <code>interface{}</code> aliased <code>any</code>, specifies no behaviour. Consequently, all built-in and user-defined types implement this interface since they all have at least no receivers bound to them. So we can supply any type as a value for the empty interface.</p>

<p>Interfaces are useful when we want to define generic behaviour that several types may need to implement. They allow us to write code using the interface - an abstraction of the implementation - instead of the implementation itself.</p>

<p>Writing code that accepts interfaces in preference to concrete types is a common pattern in Go. For example, many functions accept the <i>io.writer</i> and <i>io.reader</i> interfaces, enabling them to call the <i>Write</i> and <i>Read</i> implementations on the interface value passed. The function knows how to use the interface value because the interface defines the receiver signature  parameters and return types. It cares nothing for the underlying implementation itself, only that it <i>has</i> an implementation. </p>

<aside class="information blurb">
    <p>While accepting interface values makes code more flexible, we generally prefer not to return interfaces except in specific situations such as the one we’ll see shortly. It’s rarely a good idea to return an empty interface type. Doing so imposes a burden on the caller and can result in ugly syntax. The caller may need to perform <i>type switch</i> logic on each return value to determine what the concrete type is, and then how to handle it.</p>

</aside>

<h3 id="leanpub-auto-creating-interfaces-of-our-own" class="subsection">9.4.2 Creating interfaces of our own</h3>

<p>Consider this fictional scenario. We are writing a program that has a requirement to store data, when it restarts it should be able to access that same data. </p>

<p>We need a store for the data, and a means to write to and read from that store.  We’re not using an in-memory store such as a <i>map</i> because it can’t persist the data beyond the current runtime. We might use a map as a cache, for fast data access but we’re not doing since there’s no requirement for exceptionally fast reads and writes.</p>

<p>So, the next simplest store we could use would be a file-based store, with data getting written to disk. We decided to implement a file store and the below code is what we came up with.  Three receivers bound to the struct will let us perform all the CRUD operations we need, with the update operation being a rewrite of the entire record for an id.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 93 - Simple file store</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">filestore</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="o">//</code> <code class="n">FileStore</code> <code class="k">is</code> <code class="n">a</code> <code class="n">struct</code> <code class="n">representation</code> <code class="n">of</code> <code class="n">a</code> <code class="n">file</code> <code class="n">based</code> <code class="n">store</code>
<code class="linenos"> 4 </code><code class="n">type</code> <code class="n">FileStore</code> <code class="n">struct</code> <code class="p">{</code>
<code class="linenos"> 5 </code>	<code class="n">Folder</code> <code class="n">string</code>
<code class="linenos"> 6 </code><code class="p">}</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="o">//</code> <code class="n">Set</code> <code class="n">writes</code> <code class="n">a</code> <code class="n">payload</code> <code class="n">to</code> <code class="n">the</code> <code class="n">file</code> <code class="n">store</code>
<code class="linenos"> 9 </code><code class="k">func</code> <code class="p">(</code><code class="n">fs</code> <code class="o">*</code><code class="n">FileStore</code><code class="p">)</code> <code class="n">Set</code><code class="p">(</code><code class="n">payload</code> <code class="p">[]</code><code class="n">byte</code><code class="p">)</code> <code class="p">(</code><code class="n">string</code><code class="p">,</code> <code class="n">error</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">10 </code>	<code class="k">return</code> <code class="s2">""</code><code class="p">,</code> <code class="n">nil</code>
<code class="linenos">11 </code><code class="p">}</code>
<code class="linenos">12 </code>
<code class="linenos">13 </code><code class="o">//</code> <code class="n">Get</code> <code class="n">retrieves</code> <code class="n">an</code> <code class="n">item</code> <code class="n">of</code> <code class="n">data</code> <code class="n">from</code> <code class="n">the</code> <code class="n">store</code> <code class="n">by</code> <code class="n">id</code>
<code class="linenos">14 </code><code class="k">func</code> <code class="p">(</code><code class="n">fs</code> <code class="o">*</code><code class="n">FileStore</code><code class="p">)</code> <code class="n">Get</code><code class="p">(</code><code class="n">id</code> <code class="n">string</code><code class="p">)</code> <code class="p">([]</code><code class="n">byte</code><code class="p">,</code> <code class="n">error</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">15 </code>	<code class="k">return</code> <code class="p">[]</code><code class="n">byte</code><code class="p">{},</code> <code class="n">nil</code>
<code class="linenos">16 </code><code class="p">}</code>
<code class="linenos">17 </code>
<code class="linenos">18 </code><code class="o">//</code> <code class="n">Delete</code> <code class="n">removes</code> <code class="n">an</code> <code class="n">item</code> <code class="n">of</code> <code class="n">data</code> <code class="n">from</code> <code class="n">the</code> <code class="n">store</code> <code class="n">by</code> <code class="n">id</code>
<code class="linenos">19 </code><code class="k">func</code> <code class="p">(</code><code class="n">fs</code> <code class="o">*</code><code class="n">FileStore</code><code class="p">)</code> <code class="n">Delete</code><code class="p">(</code><code class="n">id</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code> <code class="p">{</code>
<code class="linenos">20 </code>	<code class="k">return</code> <code class="n">nil</code>
<code class="linenos">21 </code><code class="p">}</code>
</pre></div>

</figure>


<aside class="information blurb">
    <p>Note the implementation is not needed for the examples, let’s pretend we know what it is and that we have added it to the above code. For now, we can simply use NOOPs. </p>

</aside>

<p>We’d use the file store in our code like this. Again note we’re only concerned with how to create and access the store. Processing and error checking would be needed on the return values, but we’ve discarded them here.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 94 - Using the store</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"store/filestore"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="o">//</code> <code class="n">new</code> <code class="n">file</code> <code class="n">store</code>
<code class="linenos"> 7 </code>	<code class="n">fs</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="n">filestore</code><code class="o">.</code><code class="n">FileStore</code><code class="p">{</code><code class="s2">"data"</code><code class="p">}</code>
<code class="linenos"> 8 </code>
<code class="linenos"> 9 </code>	<code class="o">//</code> <code class="n">write</code> <code class="n">to</code> <code class="n">it</code>
<code class="linenos">10 </code>	<code class="nb">id</code><code class="p">,</code> <code class="n">err</code> <code class="o">:=</code> <code class="n">fs</code><code class="o">.</code><code class="n">Set</code><code class="p">([]</code><code class="n">byte</code><code class="p">(</code><code class="s2">"some data"</code><code class="p">))</code>
<code class="linenos">11 </code>	<code class="n">_</code><code class="p">,</code> <code class="n">_</code> <code class="o">=</code> <code class="nb">id</code><code class="p">,</code> <code class="n">err</code>
<code class="linenos">12 </code>
<code class="linenos">13 </code>	<code class="o">//</code> <code class="n">read</code> <code class="n">an</code> <code class="n">item</code>
<code class="linenos">14 </code>	<code class="n">data</code><code class="p">,</code> <code class="n">err</code> <code class="o">:=</code> <code class="n">fs</code><code class="o">.</code><code class="n">Get</code><code class="p">(</code><code class="s2">"xyz"</code><code class="p">)</code>
<code class="linenos">15 </code>	<code class="n">_</code><code class="p">,</code> <code class="n">_</code> <code class="o">=</code> <code class="n">data</code><code class="p">,</code> <code class="n">err</code>
<code class="linenos">16 </code>
<code class="linenos">17 </code>	<code class="o">//</code> <code class="n">delete</code> <code class="n">an</code> <code class="n">item</code>
<code class="linenos">18 </code>	<code class="n">err</code> <code class="o">=</code> <code class="n">fs</code><code class="o">.</code><code class="n">Delete</code><code class="p">(</code><code class="s2">"xyz"</code><code class="p">)</code>
<code class="linenos">19 </code>	<code class="n">_</code> <code class="o">=</code> <code class="n">err</code>
<code class="linenos">20 </code><code class="p">}</code>
</pre></div>

</figure>


<p>Everything is good. With this piece complete we can continue to write the rest of our application.</p>

<p>But, then we get a new requirement. The business wants the ability to configure additional storage types. We should support databases and also key-value stores such as <i>Redis</i> and <i>etcd</i>. The requirements do not state specifically which.</p>

<p>We now face a challenge. The requirements are vague, and we can’t possibly write implementations for every type of database or key-value store the business <i>may</i> wish to use. </p>

<p>How can we accommodate this change so that we can move on? Maybe we report that we are blocked until the business tells us exactly what it needs, or maybe we know how to use interfaces.</p>

<p>Luckily for us, we’ve recently learned about interfaces, so we decide to perform a small refactor of our project. If we refactor around interfaces we suspect we won’t need to concern ourselves with those unknown implementations at the moment, while making it very simple to accommodate them when the business makes its mind up.</p>

<p>Let’s design the interface. Where should we start?</p>

<p>Well, we know what the program needs to do regardless of the storage medium chosen. It needs to <i>read</i>, <i>write</i> and <i>delete</i> on the store. So we will create an interface that represents this behaviour.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 95 - Interface design</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code><code class="n">package</code> <code class="n">store</code>
<code class="linenos">2 </code>
<code class="linenos">3 </code><code class="o">//</code> <code class="n">ReadWriteDeleter</code> <code class="n">must</code> <code class="n">be</code> <code class="n">implemented</code> <code class="k">for</code> <code class="n">each</code> <code class="n">storage</code> <code class="n">mechanism</code>
<code class="linenos">4 </code><code class="n">type</code> <code class="n">ReadWriteDeleter</code> <code class="n">interface</code> <code class="p">{</code>
<code class="linenos">5 </code>	<code class="n">Read</code><code class="p">(</code><code class="n">id</code> <code class="n">string</code><code class="p">)</code> <code class="p">(</code><code class="n">payload</code> <code class="p">[]</code><code class="n">byte</code><code class="p">,</code> <code class="n">err</code> <code class="n">error</code><code class="p">)</code>
<code class="linenos">6 </code>	<code class="n">Write</code><code class="p">(</code><code class="n">payload</code> <code class="p">[]</code><code class="n">byte</code><code class="p">)</code> <code class="p">(</code><code class="n">id</code> <code class="n">string</code><code class="p">,</code> <code class="n">err</code> <code class="n">error</code><code class="p">)</code>
<code class="linenos">7 </code>	<code class="n">Delete</code><code class="p">(</code><code class="n">id</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code>
<code class="linenos">8 </code><code class="p">}</code>
</pre></div>

</figure>


<p>We’ve named our interface <i>ReadWriteDeleter</i> and we defined three behaviours on the interface. Though we changed the naming slightly, the signatures are otherwise the same as those of the receivers we implemented on the <code>FileStore</code> struct.</p>

<aside class="information blurb">
    <p>We should use small interfaces whenever possible, each with a limited set of behaviour since implementation is simpler. This tends to make an interface more flexible. Interfaces are also composable, just like structs, so we can build more specific large interface types from smaller interfaces by embedding them. We could for example, have composed our <i>ReadWriteDeleter</i> interface from three smaller interfaces, <i>Reader</i>, <i>Writer</i>, and <i>Deleter</i>.</p>

  <p>Observe also the naming convention. That’s generally the idiomatic way of naming an interface in Go. For example, <i>io.Reader</i> defines a <i>Read</i> receiver and <i>io.ReadWriter</i> defines both <i>Read</i> and <i>Write</i> receivers. Our <i>store.ReadWriteDeleter</i> interface defines, <i>Read</i>, <i>Write</i> and <i>Delete</i> receivers.</p>

</aside>

<p>We’re also going to add a factory function to the <i>store</i> package. This will allow us to quickly swap between stores. We use a switch statement so we can create store types when we need to. Currently, we only have one <code>case</code> statement as we only have a file store.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 96 - Implementing store.NewStore</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="o">//</code> <code class="n">NewStore</code> <code class="n">creates</code> <code class="n">a</code> <code class="n">store</code> <code class="n">from</code> <code class="n">available</code> <code class="n">stores</code><code class="p">,</code> <code class="n">depending</code> <code class="n">on</code> <code class="n">storeType</code> <code class="n">argument</code>
<code class="linenos"> 2 </code><code class="k">func</code> <code class="n">NewStore</code><code class="p">(</code><code class="n">storeType</code> <code class="n">string</code><code class="p">)</code> <code class="n">ReadWriteDeleter</code> <code class="p">{</code>
<code class="linenos"> 3 </code>	<code class="k">var</code> <code class="n">s</code> <code class="n">ReadWriteDeleter</code>
<code class="linenos"> 4 </code>	<code class="n">switch</code> <code class="n">storeType</code> <code class="p">{</code>
<code class="linenos"> 5 </code>	<code class="n">case</code> <code class="s2">"file"</code><code class="p">:</code>
<code class="linenos"> 6 </code>		<code class="n">s</code> <code class="o">=</code> <code class="o">&amp;</code><code class="n">filestore</code><code class="o">.</code><code class="n">FileStore</code><code class="p">{</code>
<code class="linenos"> 7 </code>			<code class="n">Folder</code><code class="p">:</code> <code class="s2">"data"</code><code class="p">,</code>
<code class="linenos"> 8 </code>		<code class="p">}</code>
<code class="linenos"> 9 </code>	<code class="p">}</code>
<code class="linenos">10 </code>	<code class="k">return</code> <code class="n">s</code>
<code class="linenos">11 </code><code class="p">}</code>
</pre></div>

</figure>


<p>Happy with our chosen interface design, and our <code>NewStore</code> factory function, next we’ll alter our <code>FileStore</code> struct type to make sure it implements the interface. This involves changing two receiver names.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 97 - Implementing store.ReadWriteDeleter</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">filestore</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="o">//</code> <code class="n">FileStore</code> <code class="k">is</code> <code class="n">a</code> <code class="n">struct</code> <code class="n">representation</code> <code class="n">of</code> <code class="n">a</code> <code class="n">file</code> <code class="n">based</code> <code class="n">store</code>
<code class="linenos"> 4 </code><code class="n">type</code> <code class="n">FileStore</code> <code class="n">struct</code> <code class="p">{</code>
<code class="linenos"> 5 </code>	<code class="n">Folder</code> <code class="n">string</code>
<code class="linenos"> 6 </code><code class="p">}</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="o">//</code> <code class="n">Write</code> <code class="n">writes</code> <code class="n">a</code> <code class="n">payload</code> <code class="n">to</code> <code class="n">the</code> <code class="n">file</code> <code class="n">store</code>
<code class="linenos"> 9 </code><code class="k">func</code> <code class="p">(</code><code class="n">fs</code> <code class="o">*</code><code class="n">FileStore</code><code class="p">)</code> <code class="n">Write</code><code class="p">(</code><code class="n">payload</code> <code class="p">[]</code><code class="n">byte</code><code class="p">)</code> <code class="p">(</code><code class="n">string</code><code class="p">,</code> <code class="n">error</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">10 </code>	<code class="k">return</code> <code class="s2">""</code><code class="p">,</code> <code class="n">nil</code>
<code class="linenos">11 </code><code class="p">}</code>
<code class="linenos">12 </code>
<code class="linenos">13 </code><code class="o">//</code> <code class="n">Read</code> <code class="n">retrieves</code> <code class="n">an</code> <code class="n">item</code> <code class="n">of</code> <code class="n">data</code> <code class="n">from</code> <code class="n">the</code> <code class="n">store</code> <code class="n">by</code> <code class="n">id</code>
<code class="linenos">14 </code><code class="k">func</code> <code class="p">(</code><code class="n">fs</code> <code class="o">*</code><code class="n">FileStore</code><code class="p">)</code> <code class="n">Read</code><code class="p">(</code><code class="n">id</code> <code class="n">string</code><code class="p">)</code> <code class="p">([]</code><code class="n">byte</code><code class="p">,</code> <code class="n">error</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">15 </code>	<code class="k">return</code> <code class="p">[]</code><code class="n">byte</code><code class="p">{},</code> <code class="n">nil</code>
<code class="linenos">16 </code><code class="p">}</code>
<code class="linenos">17 </code>
<code class="linenos">18 </code><code class="o">//</code> <code class="n">Delete</code> <code class="n">removes</code> <code class="n">an</code> <code class="n">item</code> <code class="n">of</code> <code class="n">data</code> <code class="n">from</code> <code class="n">the</code> <code class="n">store</code> <code class="n">by</code> <code class="n">id</code>
<code class="linenos">19 </code><code class="k">func</code> <code class="p">(</code><code class="n">fs</code> <code class="o">*</code><code class="n">FileStore</code><code class="p">)</code> <code class="n">Delete</code><code class="p">(</code><code class="n">id</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code> <code class="p">{</code>
<code class="linenos">20 </code>	<code class="k">return</code> <code class="n">nil</code>
<code class="linenos">21 </code><code class="p">}</code>
</pre></div>

</figure>


<p>The last thing we need to do is amend the code that creates and uses the store.  We’ll use the factory to create the store, and then work with the interface value’s <i>Read</i>, <i>Write</i> and <i>Delete</i> functionality in preference to a specific store type. The changes are minor.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 98 - Refactoring to use the interface</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"store/store"</code>
<code class="linenos"> 5 </code><code class="p">)</code>
<code class="linenos"> 6 </code>
<code class="linenos"> 7 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos"> 8 </code>	<code class="o">//</code> <code class="n">new</code> <code class="n">store</code><code class="p">,</code> <code class="n">currently</code> <code class="n">a</code> <code class="n">file</code> <code class="n">store</code>
<code class="linenos"> 9 </code>	<code class="n">st</code> <code class="o">:=</code> <code class="n">store</code><code class="o">.</code><code class="n">NewStore</code><code class="p">(</code><code class="s2">"file"</code><code class="p">)</code>
<code class="linenos">10 </code>
<code class="linenos">11 </code>	<code class="o">//</code> <code class="n">write</code> <code class="n">to</code> <code class="n">it</code>
<code class="linenos">12 </code>	<code class="nb">id</code><code class="p">,</code> <code class="n">err</code> <code class="o">:=</code> <code class="n">st</code><code class="o">.</code><code class="n">Write</code><code class="p">([]</code><code class="n">byte</code><code class="p">(</code><code class="s2">"some data"</code><code class="p">))</code>
<code class="linenos">13 </code>	<code class="n">_</code><code class="p">,</code> <code class="n">_</code> <code class="o">=</code> <code class="nb">id</code><code class="p">,</code> <code class="n">err</code>
<code class="linenos">14 </code>
<code class="linenos">15 </code>	<code class="o">//</code> <code class="n">read</code> <code class="n">an</code> <code class="n">item</code>
<code class="linenos">16 </code>	<code class="n">data</code><code class="p">,</code> <code class="n">err</code> <code class="o">:=</code> <code class="n">st</code><code class="o">.</code><code class="n">Read</code><code class="p">(</code><code class="s2">"xyz"</code><code class="p">)</code>
<code class="linenos">17 </code>	<code class="n">_</code><code class="p">,</code> <code class="n">_</code> <code class="o">=</code> <code class="n">data</code><code class="p">,</code> <code class="n">err</code>
<code class="linenos">18 </code>
<code class="linenos">19 </code>	<code class="o">//</code> <code class="n">delete</code> <code class="n">an</code> <code class="n">item</code>
<code class="linenos">20 </code>	<code class="n">err</code> <code class="o">=</code> <code class="n">st</code><code class="o">.</code><code class="n">Delete</code><code class="p">(</code><code class="s2">"xyz"</code><code class="p">)</code>
<code class="linenos">21 </code>	<code class="n">_</code> <code class="o">=</code> <code class="n">err</code>
<code class="linenos">22 </code><code class="p">}</code>
</pre></div>

</figure>


<p>That’s it we’re done. Our program is now working with an interface and not a specific store implementation.</p>

<p>To add a new store type, say a database, we’d create an implementation for the database, which also satisfies the <i>store.ReadWriteDeleter</i> interface, and add a case statement in the <code>store.NewStore()</code> factory to create a database store.</p>

<p>The only change we’d need to make in <code>main()</code> would be to pass “database” as an argument to <code>store.NewStore()</code> on line 9, so the factory function creates a database store instead of a file store.</p>

<p>To see how flexible our code is now that it uses interfaces, why don’t you go ahead and add a new store for yourself? It should only take minutes.</p>

<h3 id="leanpub-auto-using-interfaces-in-testing" class="subsection">9.4.3 Using interfaces in testing</h3>

<p>When testing our software, often, the code we need to test has external dependencies such as third party libraries, APIs or databases, to name just a few examples.</p>

<p>Whether these components are available during testing may depend on the type of testing undertaken. If we’re conducting <i>integration testing</i>, we’re testing the system as a whole so it could make sense to perform those tests using real implementations. If we’re conducting <i>unit testing</i>, which focuses on testing the pieces of code which comprise the program, it’s often inconvenient to test using real implementations, and in some cases it’s impossible.</p>

<p>To avoid needing real implementations, we can create <i>mock</i> or <i>fake</i> implementations of our external dependencies, and use those in our testing instead.</p>

<p>One way to do this in Go is with interfaces. By creating an interface for the external dependency, and refactoring our code to use the interface and not the dependency directly, we can create a mock/fake implementation of the dependency, one which satisfies the same interface. This is ideal when unit testing.</p>

<p>In the next example, we’ll walk step-by-step through this process.  We’ll create an abstraction for a notification service using an interface, then amend our code to use that interface. We’ll modify the notification service implementation so that it implements the interface, and finally, create a mock implementation of the service which we can use during testing.</p>

<p>Let’s begin.</p>

<p>In our current implementation <code>SendNotification()</code> calls a helper function <code>makeCallToApi()</code> to send using the external notifications API. The code inside <code>makeCallToApi()</code> is not relevant for the example, and we’re discarding any errors.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 99 - SendNotification function</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="o">//</code> <code class="n">SendNotification</code> <code class="n">sends</code> <code class="n">a</code> <code class="n">notification</code> <code class="n">using</code> <code class="n">the</code> <code class="n">external</code> <code class="n">notification</code> <code class="n">API</code><code class="o">.</code>
<code class="linenos"> 4 </code><code class="k">func</code> <code class="n">SendNotification</code><code class="p">(</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code> <code class="p">{</code>
<code class="linenos"> 5 </code>    <code class="k">if</code> <code class="n">err</code> <code class="p">:</code><code class="o">=</code> <code class="n">makeCallToAPI</code><code class="p">(</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code><code class="p">);</code> <code class="n">err</code> <code class="o">!=</code> <code class="n">nil</code> <code class="p">{</code>
<code class="linenos"> 6 </code>        <code class="k">return</code> <code class="n">err</code>
<code class="linenos"> 7 </code>    <code class="p">}</code>
<code class="linenos"> 8 </code>    <code class="k">return</code> <code class="n">nil</code>
<code class="linenos"> 9 </code><code class="p">}</code>
<code class="linenos">10 </code>
<code class="linenos">11 </code><code class="o">//</code> <code class="n">helper</code> <code class="n">to</code> <code class="n">make</code> <code class="n">the</code> <code class="n">REST</code> <code class="n">call</code> <code class="n">to</code> <code class="n">API</code> <code class="n">to</code> <code class="n">send</code> <code class="n">notification</code>
<code class="linenos">12 </code><code class="k">func</code> <code class="n">makeCallToAPI</code><code class="p">(</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code> <code class="p">{</code>
<code class="linenos">13 </code>    <code class="k">return</code> <code class="n">nil</code>
<code class="linenos">14 </code><code class="p">}</code>
<code class="linenos">15 </code>
<code class="linenos">16 </code><code class="k">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">17 </code>    <code class="n">_</code> <code class="o">=</code> <code class="n">SendNotification</code><code class="p">(</code><code class="s2">"Joe Blogs"</code><code class="p">,</code> <code class="s2">"Hello there!"</code><code class="p">)</code>
<code class="linenos">18 </code><code class="p">}</code>
</pre></div>

</figure>


<p>Let’s quickly inspect the current unit test for the <code>SendNotification()</code> function.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 100 - A basic unit test</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code><code class="k">func</code> <code class="n">TestSendNotification</code><code class="p">(</code><code class="n">t</code> <code class="o">*</code><code class="n">testing</code><code class="o">.</code><code class="n">T</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">2 </code>    <code class="n">err</code> <code class="p">:</code><code class="o">=</code> <code class="n">SendNotification</code><code class="p">(</code><code class="s2">"Test Joe Blogs"</code><code class="p">,</code> <code class="s2">"Test message"</code><code class="p">)</code>
<code class="linenos">3 </code>    <code class="k">if</code> <code class="n">err</code> <code class="o">!=</code> <code class="n">nil</code> <code class="p">{</code>
<code class="linenos">4 </code>        <code class="n">t</code><code class="o">.</code><code class="n">Errorf</code><code class="p">(</code><code class="s2">"expected nil, got %v"</code><code class="p">,</code> <code class="n">err</code><code class="p">)</code>
<code class="linenos">5 </code>    <code class="p">}</code>
<code class="linenos">6 </code><code class="p">}</code>
</pre></div>

</figure>


<p>At the moment the unit test would make calls to the notifications API. If it has a valid <i>API key</i> or <i>access token</i> testing this function could send real notifications. If it doesn’t have access - which is more likely - it will always error causing the test to fail.</p>

<p>We can’t really test it properly at the moment, but, with a little work we can do better.</p>

<p>The first thing to do is to create an interface. We’ve called it <i>Notifier</i> and it defines a single <i>Notify</i> receiver.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 101 - Notifier service interface</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code><code class="nv">package</code> <code class="nv">service</code>
<code class="linenos">2 </code>
<code class="linenos">3 </code><code class="o">//</code> <code class="nv">Notifier</code> <code class="nv">must</code> <code class="nv">be</code> <code class="nv">implemented</code> <code class="k">for</code> <code class="nv">any</code> <code class="nv">service</code> <code class="nv">we</code> <code class="nv">use</code> <code class="nv">to</code> <code class="k">send</code> <code class="nv">notifications</code>.
<code class="linenos">4 </code><code class="nv">type</code> <code class="nv">Notifier</code> <code class="nv">interface</code> {
<code class="linenos">5 </code>    <code class="nv">Notify</code><code class="ss">(</code><code class="nv">to</code> <code class="nv">string</code>, <code class="nv">notification</code> <code class="nv">string</code><code class="ss">)</code> <code class="nv">error</code>
<code class="linenos">6 </code>}
</pre></div>

</figure>


<p>Painless. Next, lets modify our existing service to use this interface. We’ll create a struct, and bind a <i>Notify</i> receiver to it, which will implement <i>Notifier</i>. Inside <code>Notify()</code> we’ll make the call to the <code>makeCallToAPI()</code> function.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 102 - Modifying the notification code</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">notifications</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="o">//</code> <code class="n">NotifyService</code> <code class="n">provides</code> <code class="k">for</code> <code class="n">sending</code> <code class="n">notifications</code> <code class="n">using</code> <code class="n">external</code> <code class="n">API</code>
<code class="linenos"> 4 </code><code class="n">type</code> <code class="n">NotifyService</code> <code class="n">struct</code> <code class="p">{}</code>
<code class="linenos"> 5 </code>
<code class="linenos"> 6 </code><code class="o">//</code> <code class="n">Notify</code> <code class="n">sends</code> <code class="n">notification</code>
<code class="linenos"> 7 </code><code class="k">func</code> <code class="p">(</code><code class="n">n</code> <code class="o">*</code><code class="n">NotifyService</code><code class="p">)</code> <code class="n">Notify</code> <code class="p">(</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code> <code class="p">{</code>
<code class="linenos"> 8 </code>    <code class="k">if</code> <code class="n">err</code> <code class="p">:</code><code class="o">=</code> <code class="n">makeCallToAPI</code><code class="p">(</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code><code class="p">);</code> <code class="n">err</code> <code class="o">!=</code> <code class="n">nil</code> <code class="p">{</code>
<code class="linenos"> 9 </code>        <code class="k">return</code> <code class="n">err</code>
<code class="linenos">10 </code>    <code class="p">}</code>
<code class="linenos">11 </code>    <code class="k">return</code> <code class="n">nil</code>
<code class="linenos">12 </code><code class="p">}</code>
<code class="linenos">13 </code>
<code class="linenos">14 </code><code class="o">//</code> <code class="n">helper</code> <code class="n">to</code> <code class="n">make</code> <code class="n">the</code> <code class="n">REST</code> <code class="n">call</code> <code class="n">to</code> <code class="n">API</code> <code class="n">to</code> <code class="n">send</code> <code class="n">notification</code>
<code class="linenos">15 </code><code class="k">func</code> <code class="n">makeCallToAPI</code><code class="p">(</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code> <code class="p">{</code>
<code class="linenos">16 </code>    <code class="k">return</code> <code class="n">nil</code>
<code class="linenos">17 </code><code class="p">}</code>
</pre></div>

</figure>


<p>The final step is to modify <code>main()</code> so it uses the interface in place of a concrete implementation.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 103 - Modify main()</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"notifications"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="o">//</code> <code class="n">SendNotification</code> <code class="n">sends</code> <code class="n">a</code> <code class="n">notification</code> <code class="n">using</code> <code class="n">a</code> <code class="n">Notifier</code> <code class="n">service</code>
<code class="linenos"> 6 </code><code class="n">func</code> <code class="n">SendNotification</code><code class="p">(</code><code class="n">svc</code> <code class="n">service</code><code class="o">.</code><code class="n">Notifier</code><code class="p">,</code> <code class="n">to</code><code class="p">,</code> <code class="n">notification</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code> <code class="p">{</code>
<code class="linenos"> 7 </code>    <code class="k">return</code> <code class="n">svc</code><code class="o">.</code><code class="n">Notify</code><code class="p">(</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code><code class="p">)</code>
<code class="linenos"> 8 </code><code class="p">}</code>
<code class="linenos"> 9 </code>
<code class="linenos">10 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">11 </code>    <code class="o">//</code> <code class="n">create</code> <code class="n">a</code> <code class="n">service</code>
<code class="linenos">12 </code>    <code class="n">notifySvc</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="n">notifications</code><code class="o">.</code><code class="n">NotifyService</code><code class="p">{}</code>
<code class="linenos">13 </code>    <code class="n">_</code> <code class="o">=</code> <code class="n">SendNotification</code><code class="p">(</code><code class="n">notifySvc</code><code class="p">,</code> <code class="s2">"Joe Blogs"</code><code class="p">,</code> <code class="s2">"Hello there!"</code><code class="p">)</code>
<code class="linenos">14 </code><code class="p">}</code>
</pre></div>

</figure>


<p>That process should feel familiar. It’s mostly the same as in the last section. We’ve already improved our code by making it more flexible. For example, should the business decide to use an alternative notifications service it would be straightforward to add.</p>

<p>But, that’s not our goal here. We want to test the code, and the changes we’ve just made, mean it’s significantly easier to do this too.</p>

<p>Rather than add an additional <i>real</i> notifications service, we’re going to add a mock notifications service. We’ll create it in the same notifications package we used for the real implementation.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 104 - Creating a mock notifications service</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">notifications</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="o">//</code> <code class="n">MockNotifyService</code> <code class="n">provides</code> <code class="k">for</code> <code class="n">sending</code> <code class="n">test</code> <code class="n">notifications</code>
<code class="linenos"> 4 </code><code class="n">type</code> <code class="n">MockNotifyService</code> <code class="n">struct</code> <code class="p">{</code>
<code class="linenos"> 5 </code>    <code class="n">sent</code> <code class="p">[][]</code><code class="n">string</code>
<code class="linenos"> 6 </code><code class="p">}</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="o">//</code> <code class="n">Notify</code> <code class="n">mocks</code> <code class="n">sending</code> <code class="n">a</code> <code class="n">notification</code> 
<code class="linenos"> 9 </code><code class="k">func</code> <code class="p">(</code><code class="n">mn</code> <code class="o">*</code><code class="n">MockNotifyService</code><code class="p">)</code> <code class="n">Notify</code> <code class="p">(</code><code class="n">to</code> <code class="n">string</code><code class="p">,</code> <code class="n">notification</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code> <code class="p">{</code>
<code class="linenos">10 </code>    <code class="n">mn</code><code class="o">.</code><code class="n">sent</code> <code class="o">=</code> <code class="n">append</code><code class="p">(</code><code class="n">mn</code><code class="o">.</code><code class="n">sent</code><code class="p">,</code> <code class="p">[]</code><code class="n">string</code><code class="p">{</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code><code class="p">})</code>
<code class="linenos">11 </code>    <code class="k">return</code> <code class="n">nil</code>
<code class="linenos">12 </code><code class="p">}</code>
</pre></div>

</figure>


<p>The mock service doesn’t make a call to the <code>makeCallToAPI()</code> helper function. Instead, it uses a slice to store any notifications which would have been sent.</p>

<p>Now we can update the unit test.  We create a pointer to a mock service and pass it as an argument to <code>SendNotification()</code> instead of the real service. </p>

<p>To verify that we did indeed send a test message, we check that an element has been added to the <code>sent</code> slice.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 105 - A better unit test</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code> 
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="k">func</code> <code class="n">TestSendNotification</code><code class="p">(</code><code class="n">t</code> <code class="o">*</code><code class="n">testing</code><code class="o">.</code><code class="n">T</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos"> 4 </code>	<code class="n">tstSvc</code> <code class="p">:</code><code class="o">=</code> <code class="o">&amp;</code><code class="n">notifications</code><code class="o">.</code><code class="n">MockNotifyService</code><code class="p">{}</code>
<code class="linenos"> 5 </code>	<code class="k">if</code> <code class="n">err</code> <code class="p">:</code><code class="o">=</code> <code class="n">SendNotification</code><code class="p">(</code><code class="n">tstSvc</code><code class="p">,</code> <code class="s2">"Test Joe Blogs"</code><code class="p">,</code> <code class="s2">"Test message"</code><code class="p">);</code> <code class="n">err</code> <code class="o">!=</code> <code class="n">nil</code> <code class="p">{</code>
<code class="linenos"> 6 </code>		<code class="n">t</code><code class="o">.</code><code class="n">Fatalf</code><code class="p">(</code><code class="s2">"Something went wrong, unexpected error: %v"</code><code class="p">,</code> <code class="n">err</code><code class="p">)</code>
<code class="linenos"> 7 </code>	<code class="p">}</code>
<code class="linenos"> 8 </code>	<code class="k">if</code> <code class="n">len</code><code class="p">(</code><code class="n">tstSvc</code><code class="o">.</code><code class="n">sent</code><code class="p">)</code> <code class="o">!=</code> <code class="mi">1</code> <code class="p">{</code>
<code class="linenos"> 9 </code>		<code class="n">t</code><code class="o">.</code><code class="n">Errorf</code><code class="p">(</code><code class="s2">"expected 1 notification, got </code><code class="si">%d</code><code class="s2">"</code><code class="p">,</code> <code class="n">len</code><code class="p">(</code><code class="n">tstSvc</code><code class="o">.</code><code class="n">sent</code><code class="p">))</code>
<code class="linenos">10 </code>	<code class="p">}</code>
<code class="linenos">11 </code>
<code class="linenos">12 </code>	<code class="o">//</code> <code class="n">check</code> <code class="n">that</code> <code class="n">we</code> <code class="n">stored</code> <code class="n">the</code> <code class="n">expected</code> <code class="n">data</code>
<code class="linenos">13 </code><code class="p">}</code>
</pre></div>

</figure>


<p>Don’t worry if the syntax of the unit test is confusing, we’ll come back to testing later when we discuss quality assurance. </p>

<p>We could go further with the test, and perhaps verify that the data stored in <code>sent</code> matches what was used in the test. This would confirm that we’re passing and handling the correct parameters in the service. You can add that piece to the test yourself if you wish.</p>

<h3 id="leanpub-auto-when-to-add-interfaces" class="subsection">9.4.4 When to add interfaces</h3>

<p>Unless we are certain that interfaces will improve our application, they shouldn’t be our starting point.  Notice, how in both the storage and unit test scenarios, the usecase for interfaces was identified after the application already existed. Consequently, the behaviour we needed to abstract was <i>fairly</i> obvious to us.</p>

<p>If we attempt to build our application around interfaces from the start, there a risk we add complexity which isn’t ever justified - what if the business never asks for another storage type, or we could pass a different API key and use a test notifications API?</p>

<p>Did we <i>really</i> need an interface to provide a mock? The modifications we made were as much about being able to inject our dependencies so that we can swap them, as interfaces specifically.</p>

<p>Why not leverage the typed nature of functions and inject the <code>makeCallToAPI()</code> function?  Then simply mock that as in the examples below?</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 106 - Injecting makeCallToAPI()</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"fmt"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="o">//</code> <code class="n">SendNotification</code> <code class="n">sends</code> <code class="n">a</code> <code class="n">notification</code> <code class="n">using</code> <code class="n">the</code> <code class="n">external</code> <code class="n">notification</code> <code class="n">API</code><code class="o">.</code>
<code class="linenos"> 6 </code><code class="n">func</code> <code class="n">SendNotification</code><code class="p">(</code><code class="n">provider</code> <code class="n">func</code><code class="p">(</code><code class="n">string</code><code class="p">,</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code><code class="p">,</code> <code class="n">to</code><code class="p">,</code> <code class="n">notification</code> <code class="n">string</code><code class="p">)</code> \
<code class="linenos"> 7 </code><code class="n">error</code> <code class="p">{</code>
<code class="linenos"> 8 </code>	<code class="k">if</code> <code class="n">err</code> <code class="o">:=</code> <code class="n">provider</code><code class="p">(</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code><code class="p">);</code> <code class="n">err</code> <code class="o">!=</code> <code class="n">nil</code> <code class="p">{</code>
<code class="linenos"> 9 </code>		<code class="k">return</code> <code class="n">err</code>
<code class="linenos">10 </code>	<code class="p">}</code>
<code class="linenos">11 </code>	<code class="k">return</code> <code class="n">nil</code>
<code class="linenos">12 </code><code class="p">}</code>
<code class="linenos">13 </code>
<code class="linenos">14 </code><code class="o">//</code> <code class="n">helper</code> <code class="n">to</code> <code class="n">make</code> <code class="n">the</code> <code class="n">REST</code> <code class="n">call</code> <code class="n">to</code> <code class="n">API</code> <code class="n">to</code> <code class="n">send</code> <code class="n">notification</code>
<code class="linenos">15 </code><code class="n">func</code> <code class="n">makeCallToAPI</code><code class="p">(</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code> <code class="p">{</code>
<code class="linenos">16 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code><code class="p">)</code>
<code class="linenos">17 </code>	<code class="k">return</code> <code class="n">nil</code>
<code class="linenos">18 </code><code class="p">}</code>
<code class="linenos">19 </code>
<code class="linenos">20 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">21 </code>	<code class="n">_</code> <code class="o">=</code> <code class="n">SendNotification</code><code class="p">(</code><code class="n">makeCallToAPI</code><code class="p">,</code> <code class="s2">"Joe Blogs"</code><code class="p">,</code> <code class="s2">"Hello there!"</code><code class="p">)</code>
<code class="linenos">22 </code><code class="p">}</code>
</pre></div>

</figure>



<figure class="code with-caption" dir="ltr">
  <figcaption>Example 107 - An alternative mock and unit test</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"testing"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="n">var</code> <code class="n">sent</code> <code class="p">[][]</code><code class="n">string</code>
<code class="linenos"> 6 </code>
<code class="linenos"> 7 </code><code class="o">//</code> <code class="n">Notify</code> <code class="n">mocks</code> <code class="n">sending</code> <code class="n">a</code> <code class="n">notification</code>
<code class="linenos"> 8 </code><code class="n">func</code> <code class="n">mockCallToAPI</code> <code class="p">(</code><code class="n">to</code> <code class="n">string</code><code class="p">,</code> <code class="n">notification</code> <code class="n">string</code><code class="p">)</code> <code class="n">error</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="n">sent</code> <code class="o">=</code> <code class="n">make</code><code class="p">([][]</code><code class="n">string</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code> <code class="o">//</code> <code class="n">reset</code> <code class="n">the</code> <code class="nb">slice</code>
<code class="linenos">10 </code>	<code class="n">sent</code> <code class="o">=</code> <code class="n">append</code><code class="p">(</code><code class="n">sent</code><code class="p">,</code> <code class="p">[]</code><code class="n">string</code><code class="p">{</code><code class="n">to</code><code class="p">,</code> <code class="n">notification</code><code class="p">})</code>
<code class="linenos">11 </code>	<code class="k">return</code> <code class="n">nil</code>
<code class="linenos">12 </code><code class="p">}</code>
<code class="linenos">13 </code>
<code class="linenos">14 </code><code class="n">func</code> <code class="n">TestSendNotification</code><code class="p">(</code><code class="n">t</code> <code class="o">*</code><code class="n">testing</code><code class="o">.</code><code class="n">T</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">15 </code>	<code class="k">if</code> <code class="n">err</code> <code class="o">:=</code> <code class="n">SendNotification</code><code class="p">(</code><code class="n">mockCallToAPI</code><code class="p">,</code> <code class="s2">"Test Joe Blogs"</code><code class="p">,</code> <code class="s2">"Test message"</code><code class="p">);</code> <code class="n">err</code> <code class="o">!=</code>\
<code class="linenos">16 </code> <code class="n">nil</code> <code class="p">{</code>
<code class="linenos">17 </code>		<code class="n">t</code><code class="o">.</code><code class="n">Fatalf</code><code class="p">(</code><code class="s2">"Something went wrong, unexpected error: %v"</code><code class="p">,</code> <code class="n">err</code><code class="p">)</code>
<code class="linenos">18 </code>	<code class="p">}</code>
<code class="linenos">19 </code>	<code class="k">if</code> <code class="nb">len</code><code class="p">(</code><code class="n">sent</code><code class="p">)</code> <code class="o">!=</code> <code class="mi">1</code> <code class="p">{</code>
<code class="linenos">20 </code>		<code class="n">t</code><code class="o">.</code><code class="n">Errorf</code><code class="p">(</code><code class="s2">"expected 1 notification, got </code><code class="si">%d</code><code class="s2">"</code><code class="p">,</code> <code class="nb">len</code><code class="p">(</code><code class="n">sent</code><code class="p">))</code>
<code class="linenos">21 </code>	<code class="p">}</code>
<code class="linenos">22 </code><code class="p">}</code>
</pre></div>

</figure>


<p>By attempting to build using interfaces too soon, we also risk creating the wrong abstractions, because there is no existing concrete implementation to use for reference.</p>

<p>We <i>could</i> end up rewriting code if we make early assumptions about the abstractions we need, which then later prove to be incorrect.</p>

<h3 id="leanpub-auto-summary" class="subsection">9.4.5 Summary</h3>

<p>That concludes our discussion on interfaces though we will touch on them again shortly when discussing both <i>type assertion</i> and <i>generics</i>. </p>

<p>In this section, we’ve compounded our knowledge of interfaces. We developed two solid examples which demonstrate how we refactor concrete implementations into abstractions using interfaces, and we’ve shown the value of interfaces in general.</p>

<p>But, we also know the risks of trying to implement interfaces prematurely, and, though the testing scenario was an excellent use case for interfaces, we saw it wasn’t the <i>interface</i> itself that made the code simple to test, but the dependency injection pattern we applied, which enabled us to substitute mock dependencies <i>during</i> testing.</p>

<h2 id="leanpub-auto-type-assertion-and-reflection" class="section">9.5 Type assertion and reflection</h2>

<p>During program execution, we may need to inspect and manipulate values of unknown type or work with concrete types represented by interface values. To do this, we can use techniques like <i>type assertion</i> and <i>reflection</i>.</p>

<h3 id="leanpub-auto-type-assertion" class="subsection">9.5.1 Type assertion</h3>

<p>Type assertion is a method for verifying the underlying type of an interface value. It allows for checking if a variable is of a specific concrete type, and if it is, obtaining a copy of its value as that type. We’re then able to work with the concrete value, not the interface value.</p>

<p>In the example below, we have a simple struct with one <code>Greeting</code> field. It satisfies <code>MyInterface</code>, so we can assign the struct value to the interface. </p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 108 - Type assertion provides the concrete type</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"fmt"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="nb">type</code> <code class="n">MyInterface</code> <code class="n">interface</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="n">Do</code><code class="p">()</code> <code class="n">error</code>
<code class="linenos"> 7 </code><code class="p">}</code>
<code class="linenos"> 8 </code>
<code class="linenos"> 9 </code><code class="nb">type</code> <code class="n">MyStruct</code> <code class="n">struct</code> <code class="p">{</code>
<code class="linenos">10 </code>	<code class="n">Greeting</code> <code class="n">string</code>
<code class="linenos">11 </code><code class="p">}</code>
<code class="linenos">12 </code>
<code class="linenos">13 </code><code class="n">func</code> <code class="p">(</code><code class="n">ms</code> <code class="n">MyStruct</code><code class="p">)</code> <code class="n">Do</code><code class="p">()</code> <code class="n">error</code> <code class="p">{</code>
<code class="linenos">14 </code>	<code class="k">return</code> <code class="n">nil</code>
<code class="linenos">15 </code><code class="p">}</code>
<code class="linenos">16 </code>
<code class="linenos">17 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">18 </code>	<code class="n">var</code> <code class="n">x</code> <code class="n">MyInterface</code>
<code class="linenos">19 </code>	<code class="n">x</code> <code class="o">=</code> <code class="n">MyStruct</code><code class="p">{</code><code class="n">Greeting</code><code class="p">:</code> <code class="s2">"Hello"</code><code class="p">}</code>
<code class="linenos">20 </code>
<code class="linenos">21 </code>	<code class="o">//</code> <code class="n">cannot</code> <code class="n">access</code> <code class="n">the</code> <code class="n">concrete</code> <code class="nb">type</code><code class="p">,</code> <code class="err">`</code><code class="n">Greeting</code><code class="err">`</code> <code class="n">field</code> <code class="ow">is</code> <code class="ow">not</code> <code class="n">visible</code>
<code class="linenos">22 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"This will generate compilation error"</code><code class="p">,</code> <code class="n">x</code><code class="o">.</code><code class="n">Greeting</code><code class="p">)</code>
<code class="linenos">23 </code>
<code class="linenos">24 </code>	<code class="o">//</code> <code class="n">perform</code> <code class="nb">type</code> <code class="n">assertion</code>
<code class="linenos">25 </code>	<code class="n">y</code> <code class="o">:=</code> <code class="n">x</code><code class="o">.</code><code class="p">(</code><code class="n">MyStruct</code><code class="p">)</code>
<code class="linenos">26 </code>
<code class="linenos">27 </code>	<code class="o">//</code> <code class="n">we</code> <code class="n">can</code> <code class="n">now</code> <code class="n">access</code> <code class="n">the</code> <code class="n">structs</code> <code class="n">fields</code>
<code class="linenos">28 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"'Greeting' set to: </code><code class="si">%s</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">y</code><code class="o">.</code><code class="n">Greeting</code><code class="p">)</code>
<code class="linenos">29 </code><code class="p">}</code>
<code class="linenos">30 </code>
<code class="linenos">31 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">n9njIiD7Kk1</code>
</pre></div>

</figure>


<p>Output: </p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>./prog.go:22:56: x.Greeting undefined <code class="o">(</code><code class="nb">type</code> MyInterface has no field or method Greet<code class="se">\</code>
<code class="linenos">2 </code>ing<code class="o">)</code>
<code class="linenos">3 </code>
<code class="linenos">4 </code>Go build failed.
</pre></div>

</figure>


<p>However, since interfaces only define behaviour and not state, we cannot access the <code>Greeting</code> field via the interface. We get a compilation error when we try.</p>

<p>Comment out line 22 and run the example again. We perform a type assertion, asserting the type is <code>MyStruct</code>.  The assertion is correct, so variable <code>y</code> receives a copy of the <code>MyStruct</code> value. With this concrete value, we can now access its receivers and fields.</p>

<p>An improperly constructed type assertion may introduce the risk of a runtime panic should the assertion fail - meaning the interface value does not hold the asserted concrete type.</p>

<p>For example, the following code will compile as expected but will panic when the program is run, since the type assertion cannot succeed. Type assertions are runtime, and not compile-time, checks.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 109 - Invalid type assertion, compiles but will panic</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="k">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos"> 4 </code>	<code class="k">var</code> <code class="n">i</code> <code class="n">interface</code><code class="p">{}</code>
<code class="linenos"> 5 </code>	<code class="n">i</code> <code class="o">=</code> <code class="s2">"this is a string"</code>
<code class="linenos"> 6 </code>
<code class="linenos"> 7 </code>	<code class="o">//</code> <code class="n">we</code> <code class="nb">assert</code> <code class="n">the</code> <code class="n">interface</code> <code class="n">contains</code> <code class="n">a</code> <code class="n">integer</code> <code class="n">value</code>
<code class="linenos"> 8 </code>	<code class="n">x</code> <code class="p">:</code><code class="o">=</code> <code class="n">i</code><code class="o">.</code><code class="p">(</code><code class="nb nb-Type">int</code><code class="p">)</code>
<code class="linenos"> 9 </code>	<code class="n">_</code> <code class="o">=</code> <code class="n">x</code>
<code class="linenos">10 </code><code class="p">}</code>
<code class="linenos">11 </code>
<code class="linenos">12 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">j3egltwQKPo</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>panic: interface conversion: interface <code class="o">{}</code> is string, not int
</pre></div>

</figure>


<p>Fortunately, Go has us covered. A type assertion returns a second, <i>boolean</i> value, which indicates the success or failure of the operation. We should always handle this second value in our code to avoid a panic.</p>

<p>In the next example, the previous code has been rewritten to avoid the panic risk. Now when the type assertion fails, <code>x</code> contains its initialised <i>zero value</i>, which is <code>0</code>.  Of course, in production, this may not be ideal either, and we may still choose to log the error and shut down the program rather than allow execution to continue. </p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 110 - Safely performing a type assertion</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"fmt"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="n">var</code> <code class="n">i</code> <code class="n">interface</code><code class="p">{}</code>
<code class="linenos"> 7 </code>	<code class="n">i</code> <code class="o">=</code> <code class="s2">"this is a string"</code>
<code class="linenos"> 8 </code>
<code class="linenos"> 9 </code>	<code class="o">//</code> <code class="n">we</code> <code class="k">assert</code> <code class="n">that</code> <code class="n">it</code> <code class="ow">is</code> <code class="ow">in</code> <code class="n">interface</code> <code class="n">contains</code> <code class="n">an</code> <code class="n">integer</code> <code class="n">value</code>
<code class="linenos">10 </code>	<code class="n">x</code><code class="p">,</code> <code class="n">ok</code> <code class="o">:=</code> <code class="n">i</code><code class="o">.</code><code class="p">(</code><code class="nb">int</code><code class="p">)</code>
<code class="linenos">11 </code>	<code class="k">if</code> <code class="n">ok</code> <code class="p">{</code>
<code class="linenos">12 </code>		<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"We have an integer of: </code><code class="si">%d</code><code class="s2">"</code><code class="p">,</code> <code class="n">x</code><code class="p">)</code>
<code class="linenos">13 </code>	<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
<code class="linenos">14 </code>		<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"We don't have an integer, setting to zero value: </code><code class="si">%d</code><code class="s2">"</code><code class="p">,</code> <code class="n">x</code><code class="p">)</code>
<code class="linenos">15 </code>	<code class="p">}</code>
<code class="linenos">16 </code><code class="p">}</code>
<code class="linenos">17 </code>
<code class="linenos">18 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="mi">3</code><code class="n">jfW7_hkRjM</code>
</pre></div>

</figure>


<p>Since interfaces can be satisfied by many types, we often can’t assert that the interface value holds a single type. So, in this situation we can use a special <i>type switch</i> assertion to determine which, of any number of concrete types, is contained in the interface value.</p>

<p>A <i>type switch</i> style of assertion also allows us to provide a <i>default</i> case which is useful should the interface hold an unexpected type. Note, that a type switch assertion will not panic, even if no default case statement is supplied. </p>

<p>The code in the example below demonstrates a <i>type switch</i> style assertion.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 111 - Type switch style assertion with default case</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"fmt"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="n">var</code> <code class="n">i</code> <code class="n">interface</code><code class="p">{}</code> <code class="o">=</code> <code class="s2">"hello"</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code>	<code class="n">switch</code> <code class="n">v</code> <code class="o">:=</code> <code class="n">i</code><code class="o">.</code><code class="p">(</code><code class="nb">type</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="n">case</code> <code class="nb">int</code><code class="p">:</code>
<code class="linenos">10 </code>		<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"i is an int with value %v</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">v</code><code class="p">)</code>
<code class="linenos">11 </code>	<code class="n">case</code> <code class="n">string</code><code class="p">:</code>
<code class="linenos">12 </code>		<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"i is a string with value %v</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">v</code><code class="p">)</code>
<code class="linenos">13 </code>	<code class="n">default</code><code class="p">:</code>
<code class="linenos">14 </code>		<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"i is of an unknown type with value %v</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">v</code><code class="p">)</code>
<code class="linenos">15 </code>	<code class="p">}</code>
<code class="linenos">16 </code><code class="p">}</code>
<code class="linenos">17 </code>
<code class="linenos">18 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="mi">0</code><code class="n">ovjw0QFJtL</code>
</pre></div>

</figure>


<p>So, in summary, <i>type assertion</i> is used when we know the concrete type stored in the interface value at compile time, and we want to get and use the underlying value during runtime. It could be a single type in the interface or one of several types which satisfy that interface. Correctly used, type assertion can provide a safe and performant conversion of the abstract interface value into its concrete type.</p>

<h3 id="leanpub-auto-reflection" class="subsection">9.5.2 Reflection</h3>

<p>Reflection allows us to inspect the <i>type</i> and <i>value</i> of a variable at runtime.</p>

<p>We use the standard library’s <i>reflect</i> package to obtain information about a variable. We’re also able to manipulate the variable, for instance calling its receivers and updating its fields, using the same <i>reflect</i> package.</p>

<aside class="information blurb">
    <p>Note, only exported struct fields are accessible using reflection. Attempting to access an unexported field will result in a panic.</p>

</aside>

<p>Let’s now look at a few common applications of the reflect package. In this first example we use reflection to discover the type of a variable.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 112 - Discover the type of a variable</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code>	<code class="s2">"reflect"</code>
<code class="linenos"> 6 </code><code class="p">)</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="n">x</code> <code class="o">:=</code> <code class="s2">"hello"</code>
<code class="linenos">10 </code>	<code class="n">t</code> <code class="o">:=</code> <code class="n">reflect</code><code class="o">.</code><code class="n">TypeOf</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="linenos">11 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">t</code><code class="p">)</code>
<code class="linenos">12 </code><code class="p">}</code>
<code class="linenos">13 </code>
<code class="linenos">14 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">HFJswkAEnB5</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>string
<code class="linenos">2 </code>
<code class="linenos">3 </code>Program exited.
</pre></div>

</figure>


<p>Next, we’ll use reflection to inspect a variable to determine if it holds a value or a pointer.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 113 - Does a variable hold a value or a pointer?</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code>	<code class="s2">"reflect"</code>
<code class="linenos"> 6 </code><code class="p">)</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="n">x</code> <code class="o">:=</code> <code class="s2">"hello"</code> <code class="o">//</code> <code class="n">value</code>
<code class="linenos">10 </code>	<code class="n">y</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="n">x</code>      <code class="o">//</code> <code class="n">pointer</code>
<code class="linenos">11 </code>
<code class="linenos">12 </code>	<code class="n">v1</code> <code class="o">:=</code> <code class="n">reflect</code><code class="o">.</code><code class="n">ValueOf</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
<code class="linenos">13 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"x is pointer:"</code><code class="p">,</code> <code class="n">v1</code><code class="o">.</code><code class="n">Kind</code><code class="p">()</code> <code class="o">==</code> <code class="n">reflect</code><code class="o">.</code><code class="n">Ptr</code><code class="p">)</code>
<code class="linenos">14 </code>
<code class="linenos">15 </code>	<code class="n">v2</code> <code class="o">:=</code> <code class="n">reflect</code><code class="o">.</code><code class="n">ValueOf</code><code class="p">(</code><code class="n">y</code><code class="p">)</code>
<code class="linenos">16 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"y is a pointer:"</code><code class="p">,</code> <code class="n">v2</code><code class="o">.</code><code class="n">Kind</code><code class="p">()</code> <code class="o">==</code> <code class="n">reflect</code><code class="o">.</code><code class="n">Ptr</code><code class="p">)</code>
<code class="linenos">17 </code><code class="p">}</code>
<code class="linenos">18 </code>
<code class="linenos">19 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">Y7p3BSuVGjN</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>x is pointer: <code class="nb">false</code>
<code class="linenos">2 </code>y is a pointer: <code class="nb">true</code>
<code class="linenos">3 </code>
<code class="linenos">4 </code>Program exited.
</pre></div>

</figure>


<p>In this third example, we’re going to use reflection to work with both the exported fields and receivers of a struct.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 114 - Working with struct fields and receivers</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code>	<code class="s2">"reflect"</code>
<code class="linenos"> 6 </code><code class="p">)</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="nb">type</code> <code class="n">Person</code> <code class="n">struct</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="n">Age</code> <code class="nb">int</code>
<code class="linenos">10 </code><code class="p">}</code>
<code class="linenos">11 </code>
<code class="linenos">12 </code><code class="n">func</code> <code class="p">(</code><code class="n">m</code> <code class="o">*</code><code class="n">Person</code><code class="p">)</code> <code class="n">SayHello</code><code class="p">(</code><code class="n">name</code> <code class="n">string</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">13 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"Hello </code><code class="si">%s</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">name</code><code class="p">)</code>
<code class="linenos">14 </code><code class="p">}</code>
<code class="linenos">15 </code>
<code class="linenos">16 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">17 </code>	<code class="n">p</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="n">Person</code><code class="p">{</code><code class="n">Age</code><code class="p">:</code> <code class="mi">22</code><code class="p">}</code>
<code class="linenos">18 </code>	<code class="n">v</code> <code class="o">:=</code> <code class="n">reflect</code><code class="o">.</code><code class="n">ValueOf</code><code class="p">(</code><code class="n">p</code><code class="p">)</code>
<code class="linenos">19 </code>
<code class="linenos">20 </code>	<code class="o">//</code> <code class="n">call</code> <code class="n">the</code> <code class="n">receiver</code><code class="o">/</code><code class="n">method</code> <code class="k">with</code> <code class="n">argument</code>
<code class="linenos">21 </code>	<code class="n">sayHello</code> <code class="o">:=</code> <code class="n">v</code><code class="o">.</code><code class="n">MethodByName</code><code class="p">(</code><code class="s2">"SayHello"</code><code class="p">)</code>
<code class="linenos">22 </code>	<code class="n">name</code> <code class="o">:=</code> <code class="n">reflect</code><code class="o">.</code><code class="n">ValueOf</code><code class="p">(</code><code class="s2">"Joe Blogs"</code><code class="p">)</code>
<code class="linenos">23 </code>	<code class="n">sayHello</code><code class="o">.</code><code class="n">Call</code><code class="p">([]</code><code class="n">reflect</code><code class="o">.</code><code class="n">Value</code><code class="p">{</code><code class="n">reflect</code><code class="o">.</code><code class="n">Value</code><code class="p">(</code><code class="n">name</code><code class="p">)})</code>
<code class="linenos">24 </code>
<code class="linenos">25 </code>	<code class="o">//</code> <code class="n">access</code> <code class="n">the</code> <code class="n">Age</code> <code class="n">field</code><code class="p">,</code> <code class="ow">and</code> <code class="n">change</code> <code class="n">it</code>
<code class="linenos">26 </code>	<code class="n">age</code> <code class="o">:=</code> <code class="n">v</code><code class="o">.</code><code class="n">Elem</code><code class="p">()</code><code class="o">.</code><code class="n">FieldByName</code><code class="p">(</code><code class="s2">"Age"</code><code class="p">)</code>
<code class="linenos">27 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"Current age:"</code><code class="p">,</code> <code class="n">age</code><code class="o">.</code><code class="n">Int</code><code class="p">())</code>
<code class="linenos">28 </code>	<code class="n">age</code><code class="o">.</code><code class="n">SetInt</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code>
<code class="linenos">29 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"New age:"</code><code class="p">,</code> <code class="n">age</code><code class="o">.</code><code class="n">Int</code><code class="p">())</code>
<code class="linenos">30 </code><code class="p">}</code>
<code class="linenos">31 </code>
<code class="linenos">32 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">D1GKlMeHs0V</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>Hello Joe Blogs
<code class="linenos">2 </code>Current age: <code class="m">22</code>
<code class="linenos">3 </code>New age: <code class="m">42</code>
<code class="linenos">4 </code>
<code class="linenos">5 </code>Program exited.
</pre></div>

</figure>


<p>As we can see, reflection is a powerful tool. Some tasks would not be possible without the dynamic type checking provided by reflection, but remember, with great power comes great responsibility.</p>

<p>Reflection adds significant complexity, making our code harder to read and understand, but it also has a performance cost.</p>

<p>Reflection is slower than direct access because it involves checking and converting between different types. Reflection uses heap memory, and allocations on the heap must be managed by the garbage collector. In tight or high iteration loops, the impact of reflection on speed and memory may be significant.</p>

<p>The following simple example compares the speed of direct variable access, with access via reflection.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 115 - Speed of direct access vs reflection</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code>	<code class="s2">"reflect"</code>
<code class="linenos"> 6 </code>	<code class="s2">"time"</code>
<code class="linenos"> 7 </code><code class="p">)</code>
<code class="linenos"> 8 </code>
<code class="linenos"> 9 </code><code class="n">var</code> <code class="n">i</code> <code class="nb">int</code> <code class="o">=</code> <code class="mi">42</code>
<code class="linenos">10 </code>
<code class="linenos">11 </code><code class="n">func</code> <code class="n">DirectAccess</code><code class="p">()</code> <code class="n">time</code><code class="o">.</code><code class="n">Duration</code> <code class="p">{</code>
<code class="linenos">12 </code>	<code class="n">start</code> <code class="o">:=</code> <code class="n">time</code><code class="o">.</code><code class="n">Now</code><code class="p">()</code>
<code class="linenos">13 </code>	<code class="k">for</code> <code class="n">j</code> <code class="o">:=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">j</code> <code class="o">&lt;</code> <code class="mi">100000</code><code class="p">;</code> <code class="n">j</code><code class="o">++</code> <code class="p">{</code>
<code class="linenos">14 </code>		<code class="n">val</code> <code class="o">:=</code> <code class="n">i</code>
<code class="linenos">15 </code>		<code class="n">_</code> <code class="o">=</code> <code class="n">val</code>
<code class="linenos">16 </code>	<code class="p">}</code>
<code class="linenos">17 </code>	<code class="n">elapsed</code> <code class="o">:=</code> <code class="n">time</code><code class="o">.</code><code class="n">Since</code><code class="p">(</code><code class="n">start</code><code class="p">)</code>
<code class="linenos">18 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"Direct variable access: </code><code class="si">%s</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">elapsed</code><code class="p">)</code>
<code class="linenos">19 </code>	<code class="k">return</code> <code class="n">elapsed</code>
<code class="linenos">20 </code><code class="p">}</code>
<code class="linenos">21 </code>
<code class="linenos">22 </code><code class="n">func</code> <code class="n">ReflectAccess</code><code class="p">()</code> <code class="n">time</code><code class="o">.</code><code class="n">Duration</code> <code class="p">{</code>
<code class="linenos">23 </code>	<code class="n">start</code> <code class="o">:=</code> <code class="n">time</code><code class="o">.</code><code class="n">Now</code><code class="p">()</code>
<code class="linenos">24 </code>	<code class="k">for</code> <code class="n">j</code> <code class="o">:=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">j</code> <code class="o">&lt;</code> <code class="mi">100000</code><code class="p">;</code> <code class="n">j</code><code class="o">++</code> <code class="p">{</code>
<code class="linenos">25 </code>		<code class="n">val</code> <code class="o">:=</code> <code class="n">reflect</code><code class="o">.</code><code class="n">ValueOf</code><code class="p">(</code><code class="n">i</code><code class="p">)</code>
<code class="linenos">26 </code>		<code class="n">_</code> <code class="o">=</code> <code class="n">val</code>
<code class="linenos">27 </code>	<code class="p">}</code>
<code class="linenos">28 </code>	<code class="n">elapsed</code> <code class="o">:=</code> <code class="n">time</code><code class="o">.</code><code class="n">Since</code><code class="p">(</code><code class="n">start</code><code class="p">)</code>
<code class="linenos">29 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"Access using reflection: </code><code class="si">%s</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="n">elapsed</code><code class="p">)</code>
<code class="linenos">30 </code>	<code class="k">return</code> <code class="n">elapsed</code>
<code class="linenos">31 </code><code class="p">}</code>
<code class="linenos">32 </code>
<code class="linenos">33 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">34 </code>	<code class="n">elapsed1</code> <code class="o">:=</code> <code class="n">DirectAccess</code><code class="p">()</code>
<code class="linenos">35 </code>	<code class="n">elapsed2</code> <code class="o">:=</code> <code class="n">ReflectAccess</code><code class="p">()</code>
<code class="linenos">36 </code>	<code class="n">inc</code> <code class="o">:=</code> <code class="p">((</code><code class="n">elapsed2</code> <code class="o">-</code> <code class="n">elapsed1</code><code class="p">)</code> <code class="o">/</code> <code class="n">elapsed1</code><code class="p">)</code> <code class="o">*</code> <code class="mi">100</code>
<code class="linenos">37 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Printf</code><code class="p">(</code><code class="s2">"Reflection takes </code><code class="si">%d%%</code><code class="s2"> longer than direct access"</code><code class="p">,</code> <code class="n">inc</code><code class="p">)</code>
<code class="linenos">38 </code><code class="p">}</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>Direct variable access: <code class="m">34</code>.685µs
<code class="linenos">2 </code>Access using reflection: <code class="m">314</code>.971µs
<code class="linenos">3 </code>Reflection takes <code class="m">800</code>% longer than direct access%    
</pre></div>

</figure>


<h2 id="leanpub-auto-introducing-generics" class="section">9.6 Introducing Generics</h2>

<p><i>Generics</i> are a feature in most statically typed programming languages. Generics, or generic programming, allows us to write more reusable code by abstracting types away. It provides a way to reduce duplication, which would otherwise arise when writing functionality compatible with more than just a single type.</p>

<p>Go wasn’t designed with support for generics but after much debate over several years, generics support was added to the language in version 1.18.</p>

<p>Mechanically, generics enable us to write code with values whose type can be specified later at the point of use, while maintaining type safety using syntax to place constraints on which types may be accepted.</p>

<p>In a later section we will examine generics in detail, and through several examples, we’ll learn how to do generic programming in Go.</p>

<p>But first we need to understand the problem, which is essentially a side-effect of <i>static typing</i>.</p>

<h3 id="leanpub-auto-before-generics" class="subsection">9.6.1 Before generics</h3>

<p>Consider the simple <code>sumInt64()</code> function in the following example. It’s designed to add two integers of the <i>int64</i> type. An unremarkable, trivial function.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 116 - Adding two <i>int64</i> integers</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"fmt"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="n">func</code> <code class="n">sumInt64</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">int64</code><code class="p">)</code> <code class="n">int64</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code>
<code class="linenos"> 7 </code><code class="p">}</code>
<code class="linenos"> 8 </code>
<code class="linenos"> 9 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">10 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">sumInt64</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">))</code>
<code class="linenos">11 </code><code class="p">}</code>
<code class="linenos">12 </code>
<code class="linenos">13 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">XDU49bgxRs_j</code>
</pre></div>

</figure>


<p>The problem is that its parameter and return typing mean it can only add <i>int64</i> types. </p>

<p>But, we can’t count on all integers being of this type, so what do we do when we need to add <i>int8</i>, <i>int16</i>, or <i>int32</i> typed integers? </p>

<p>One obvious approach is to duplicate the same function three more times, one for each integer type that we’ll need to add. </p>

<p>In the following example, we implement those new functions. Notice, that the function body is always the same, only the <i>parameter</i> and <i>return</i> types are different.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 117 - Adding other integer types</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="s2">"fmt"</code>
<code class="linenos"> 4 </code>
<code class="linenos"> 5 </code><code class="n">func</code> <code class="n">sumInt8</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">int8</code><code class="p">)</code> <code class="n">int8</code> <code class="p">{</code>
<code class="linenos"> 6 </code>	<code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code>
<code class="linenos"> 7 </code><code class="p">}</code>
<code class="linenos"> 8 </code>
<code class="linenos"> 9 </code><code class="n">func</code> <code class="n">sumInt16</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">int16</code><code class="p">)</code> <code class="n">int16</code> <code class="p">{</code>
<code class="linenos">10 </code>	<code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code>
<code class="linenos">11 </code><code class="p">}</code>
<code class="linenos">12 </code>
<code class="linenos">13 </code><code class="n">func</code> <code class="n">sumInt32</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">int32</code><code class="p">)</code> <code class="n">int32</code> <code class="p">{</code>
<code class="linenos">14 </code>	<code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code>
<code class="linenos">15 </code><code class="p">}</code>
<code class="linenos">16 </code>
<code class="linenos">17 </code><code class="n">func</code> <code class="n">sumInt64</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">int64</code><code class="p">)</code> <code class="n">int64</code> <code class="p">{</code>
<code class="linenos">18 </code>	<code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code>
<code class="linenos">19 </code><code class="p">}</code>
<code class="linenos">20 </code>
<code class="linenos">21 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">22 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">sumInt8</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">))</code>
<code class="linenos">23 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">sumInt16</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">))</code>
<code class="linenos">24 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">sumInt32</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">))</code>
<code class="linenos">25 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">sumInt64</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">))</code>
<code class="linenos">26 </code><code class="p">}</code>
<code class="linenos">27 </code>
<code class="linenos">28 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">Q3SzagyF</code><code class="o">-</code><code class="n">CS</code>
</pre></div>

</figure>


<p>With the function duplicated, we can now add any integer type, which is great, but it does feel a bit awkward. All that duplication just to add two numbers?</p>

<p>Perhaps there is another way to solve the problem.</p>

<p>Well, there is/was. Before Go 1.18 we could already use a <i>form</i> of generic programming with <i>interfaces</i>. By using the empty interface specifically, rather than duplicating the function as we did in the previous example, we could write a single implementation that accepts the <code>interface{}</code> type as parameters and then performs a <i>type switch</i> on the arguments to determine how to handle them. </p>

<p>This approach has drawbacks too, which we will come to, but first, let’s look at how we could write a single function that could add any pair of same typed integers.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 118 - A single sumIntAny implementation</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"errors"</code>
<code class="linenos"> 5 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 6 </code>	<code class="s2">"reflect"</code>
<code class="linenos"> 7 </code><code class="p">)</code>
<code class="linenos"> 8 </code>
<code class="linenos"> 9 </code><code class="n">func</code> <code class="n">sumIntAny</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">interface</code><code class="p">{})</code> <code class="p">(</code><code class="n">interface</code><code class="p">{},</code> <code class="n">error</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">10 </code>	<code class="k">if</code> <code class="n">reflect</code><code class="o">.</code><code class="n">TypeOf</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="o">!=</code> <code class="n">reflect</code><code class="o">.</code><code class="n">TypeOf</code><code class="p">(</code><code class="n">y</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">11 </code>		<code class="k">return</code> <code class="n">nil</code><code class="p">,</code> <code class="n">errors</code><code class="o">.</code><code class="n">New</code><code class="p">(</code><code class="s2">"mismatched  types"</code><code class="p">)</code>
<code class="linenos">12 </code>	<code class="p">}</code>
<code class="linenos">13 </code>
<code class="linenos">14 </code>	<code class="n">switch</code> <code class="n">v</code> <code class="o">:=</code> <code class="n">x</code><code class="o">.</code><code class="p">(</code><code class="nb">type</code><code class="p">)</code> <code class="p">{</code>
<code class="linenos">15 </code>	<code class="n">case</code> <code class="n">int8</code><code class="p">:</code>
<code class="linenos">16 </code>		<code class="k">return</code> <code class="n">v</code> <code class="o">+</code> <code class="n">y</code><code class="o">.</code><code class="p">(</code><code class="n">int8</code><code class="p">),</code> <code class="n">nil</code>
<code class="linenos">17 </code>	<code class="n">case</code> <code class="n">int16</code><code class="p">:</code>
<code class="linenos">18 </code>		<code class="k">return</code> <code class="n">v</code> <code class="o">+</code> <code class="n">y</code><code class="o">.</code><code class="p">(</code><code class="n">int16</code><code class="p">),</code> <code class="n">nil</code>
<code class="linenos">19 </code>	<code class="n">case</code> <code class="n">int32</code><code class="p">:</code>
<code class="linenos">20 </code>		<code class="k">return</code> <code class="n">v</code> <code class="o">+</code> <code class="n">y</code><code class="o">.</code><code class="p">(</code><code class="n">int32</code><code class="p">),</code> <code class="n">nil</code>
<code class="linenos">21 </code>	<code class="n">case</code> <code class="n">int64</code><code class="p">:</code>
<code class="linenos">22 </code>		<code class="k">return</code> <code class="n">v</code> <code class="o">+</code> <code class="n">y</code><code class="o">.</code><code class="p">(</code><code class="n">int64</code><code class="p">),</code> <code class="n">nil</code>
<code class="linenos">23 </code>	<code class="p">}</code>
<code class="linenos">24 </code>
<code class="linenos">25 </code>	<code class="k">return</code> <code class="n">nil</code><code class="p">,</code> <code class="n">nil</code>
<code class="linenos">26 </code><code class="p">}</code>
<code class="linenos">27 </code>
<code class="linenos">28 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">29 </code>	<code class="n">res</code><code class="p">,</code> <code class="n">err</code> <code class="o">:=</code> <code class="n">sumIntAny</code><code class="p">(</code><code class="n">int8</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code> <code class="n">int8</code><code class="p">(</code><code class="mi">2</code><code class="p">))</code>
<code class="linenos">30 </code>	<code class="k">if</code> <code class="n">err</code> <code class="o">!=</code> <code class="n">nil</code> <code class="p">{</code>
<code class="linenos">31 </code>		<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">err</code><code class="p">)</code>
<code class="linenos">32 </code>	<code class="p">}</code>
<code class="linenos">33 </code>
<code class="linenos">34 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"Result:"</code><code class="p">,</code> <code class="n">res</code><code class="p">)</code>
<code class="linenos">35 </code>	<code class="o">//</code><code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="s2">"Addition:"</code><code class="p">,</code> <code class="n">res</code><code class="o">+</code><code class="n">res</code><code class="p">)</code>
<code class="linenos">36 </code><code class="p">}</code>
<code class="linenos">37 </code>
<code class="linenos">38 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">GZ0JOBSwu9_n</code>
</pre></div>

</figure>


<p>One problem is evident immediately.  The function is now significantly more complex.  </p>

<p>We need to call it by explicitly stating which integer types we are passing. We need to check that whatever values are passed are the same concrete type so we can add them, and we have an error return value in case they are not.</p>

<p>We’re using a <i>type switch</i> to handle the different types that could be represented by <code>interface{}</code> before performing the integer addition. But what if a string is passed, we don’t handle strings currently, and we should probably return an error?</p>

<p>Another problem is the return type. Without performing a type conversion, we have to return the same type as was passed. Since this can be one of four integer types, we can only represent this with the empty interface.</p>

<p>We could choose to convert to an arbitrary integer type and return that type, but which one? If the caller passes <i>int8</i> values, does it make sense to return an <i>int64</i> result?</p>

<p>So we stick with the empty interface return, but that creates friction for the caller. The calling code, must introspect the interface, probably with another <i>type switch</i>.</p>

<p>The <code>fmt.Println()</code> performs that type switch internally, which is why it can print the value held in the interface, but try uncommenting line 35 to perform the simple addition. The program won’t compile.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>./prog.go:35:27: invalid operation: operator + not defined on res <code class="o">(</code>variable of <code class="nb">type</code> <code class="se">\</code>
<code class="linenos">2 </code>interface<code class="o">{})</code>
<code class="linenos">3 </code>
<code class="linenos">4 </code>Go build failed.
</pre></div>

</figure>


<p>So both solutions are clunky when you stop and think, but as Go developers, we’ve never known any different. This is just how it is - the price of type safety!</p>

<p>But, for other developers coming from languages which support generic programming, this is not how we should do it at all. They may find the above approaches quite naive compared to a solution based on generics.</p>

<p>Their frustration is genuine. Perhaps there is a better way?</p>

<h3 id="leanpub-auto-solving-the-problem-with-generics" class="subsection">9.6.2 Solving the problem with generics</h3>

<p>In this section, we’re going to tackle the same problem using generics. </p>

<p>We’ll start with a simple but naive example, and build on that over several more examples until we understand everything that the current implementation of generics gives us, plus what might come in later versions of Go.</p>

<aside class="information blurb">
    <p>To work with generics examples locally, you’ll need a Go version of 1.18 or above.  At the time of writing the Go Playground has Go 1.19 available, so all the examples included here, will run over there.</p>

</aside>

<p>One way a generic function differs from a normal function is that we can pass additional type parameters with constraints. </p>

<p>Think of these as placeholders for type.  The concrete type will be assigned by the compiler when the function is called. The constraint provides some hints to the compiler about what that type is allowed to be.  This means some checks are possible during compilation, and we’ll see this in action shortly.</p>

<p>The type parameters together with their constraints are passed in square braces which must immediately follow the function’s name. </p>

<p>In the snippet below we illustrate with a single type parameter and constraint. This is sufficient for our solution, but we’re not restricted to a single type parameter/constraint, and we’ll show an example of that later on.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code><code class="n">func</code> <code class="n">SumAny</code><code class="p">[</code><code class="n">T</code> <code class="n">any</code><code class="p">]</code> <code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">T</code><code class="p">)</code> <code class="n">T</code> <code class="p">{</code>
<code class="linenos">2 </code>    <code class="p">...</code>
<code class="linenos">3 </code><code class="p">}</code>
</pre></div>

</figure>


<p>So how do we reason about this unusual syntax? Let’s walk through it.</p>

<p><code>T</code>, is a placeholder or <i>alias</i> for a <i>type</i>  which has the constraint <code>any</code> which means it can be any type. We could have passed the empty interface type, <code>interface{}</code> instead. </p>

<p>Both <code>x</code> and <code>y</code> parameters use the type <i>alias</i> for their type. The single return value is also using the alias. So, whatever type is passed for <code>x</code> and <code>y</code> - which must be the same - will also be the return type.</p>

<p>It’s like a template, with real types being substituted for the placeholders when they become known. </p>

<p>The capitalization of the type parameter <code>T</code> is not a requirement, but things get a little (very) confusing if we mix lowercase type parameters with variable parameters. We’re adopting the capitalization convention to improve readability. </p>

<p>Finally, <code>T</code> has no special significance, we could have used any name for the type parameter. Single letter or a semantic name. Once again, convention is good. We’ll use the single letter, just as we’ll use capitalisation.</p>

<p>So, now that we understand the semantics a little better, let’s implement that function body of the <code>SumAny()</code> function. </p>

<p>It should be straightforward enough.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 119 - A generic implementation of SumAny</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code>	<code class="s2">"reflect"</code>
<code class="linenos"> 6 </code><code class="p">)</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="n">func</code> <code class="n">SumAny</code><code class="p">[</code><code class="n">T</code> <code class="nb">any</code><code class="p">](</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">T</code><code class="p">)</code> <code class="n">T</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code>
<code class="linenos">10 </code><code class="p">}</code>
<code class="linenos">11 </code>
<code class="linenos">12 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">13 </code>	<code class="n">res</code> <code class="o">:=</code> <code class="n">SumAny</code><code class="p">(</code><code class="n">int16</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code> <code class="n">int16</code><code class="p">(</code><code class="mi">2</code><code class="p">))</code>
<code class="linenos">14 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">res</code><code class="p">)</code>
<code class="linenos">15 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">reflect</code><code class="o">.</code><code class="n">TypeOf</code><code class="p">(</code><code class="n">res</code><code class="p">))</code>
<code class="linenos">16 </code><code class="p">}</code>
<code class="linenos">17 </code>
<code class="linenos">18 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">jbzggpV7uM8</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>./prog.go:9:9: invalid operation: operator + not defined on x <code class="o">(</code>variable of <code class="nb">type</code> T co<code class="se">\</code>
<code class="linenos">2 </code>nstrained by any<code class="o">)</code>
<code class="linenos">3 </code>
<code class="linenos">4 </code>Go build failed.
</pre></div>

</figure>


<p>It doesn’t compile. </p>

<p>The constraint we specified allows this function to accept <i>any</i> type, but not all types can be summed with the addition operator, since not all types are numbers. </p>

<p>The compiler recognises this during compilation, so this does’t introduce a panic risk fortunately. It looks like what we need instead is a constraint that accepts only <i>any</i> integer type?</p>

<p>There are two ways we can achieve this. We can use a type parameter constraint list or we can create our own constraint using an interface. </p>

<p>We’ll implement the same function again using both approaches.</p>

<p>First, let’s use a type constraint list. We need to specify all valid types for our function and we do this using a <i>pipe</i> delimited list.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code>	<code class="s2">"reflect"</code>
<code class="linenos"> 6 </code><code class="p">)</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="n">func</code> <code class="n">SumAny</code><code class="p">[</code><code class="n">T</code> <code class="n">int8</code> <code class="o">|</code> <code class="n">int32</code> <code class="o">|</code> <code class="n">int64</code> <code class="o">|</code> <code class="nb">int</code><code class="p">](</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">T</code><code class="p">)</code> <code class="n">T</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code>
<code class="linenos">10 </code><code class="p">}</code>
<code class="linenos">11 </code>
<code class="linenos">12 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">13 </code>	<code class="n">res</code> <code class="o">:=</code> <code class="n">SumAny</code><code class="p">(</code><code class="n">int16</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code> <code class="n">int16</code><code class="p">(</code><code class="mi">2</code><code class="p">))</code>
<code class="linenos">14 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">res</code><code class="p">)</code>
<code class="linenos">15 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">reflect</code><code class="o">.</code><code class="n">TypeOf</code><code class="p">(</code><code class="n">res</code><code class="p">))</code>
<code class="linenos">16 </code><code class="p">}</code>
<code class="linenos">17 </code>
<code class="linenos">18 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">yZemwfvY6ST</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>./prog.go:13:15: int16 does not implement int8<code class="p">|</code>int32<code class="p">|</code>int64<code class="p">|</code>int <code class="o">(</code>int16 missing <code class="k">in</code> int<code class="se">\</code>
<code class="linenos">2 </code><code class="m">8</code> <code class="p">|</code> int32 <code class="p">|</code> int64 <code class="p">|</code> int<code class="o">)</code>
<code class="linenos">3 </code>
<code class="linenos">4 </code>Go build failed.
</pre></div>

</figure>


<p>Again it doesn’t build. This time, because we are passing <code>int16</code> types to the function, and we deliberately didn’t include that type in the constraint list. </p>

<p>Add it to the list and run the example again - don’t forget the pipe separator! </p>

<p>You should now see this output, and notice the return type used was <code>int16</code> too, because the type placeholder <code>T</code> became <code>int16</code> when the function was called.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code><code class="m">3</code>
<code class="linenos">2 </code>int16
<code class="linenos">3 </code>
<code class="linenos">4 </code>Program exited.
</pre></div>

</figure>


<p>We’ve just written our first generic function in Go! The function signature is <i>bit</i> harder to read, but it’s avoided us duplicating the function three or four times. Neither did we need to perform complex type switch style assertions in this single implementation. In fact the function body is the same as we started with.</p>

<p>However, we can do better.  We can create our own constraints, which are interfaces basically, and specify the types allowed for that constraint. This single act will restore order in our codebase.</p>

<aside class="information blurb">
    <p>Go has two built-in constraints <i>any</i>, which we’ve seen, and <i>comparable</i>, which allows any type which supports equality comparisons with the <code>==</code> and <code>!=</code> operators.</p>

  <p>In later releases it’s probable that the standard library will include a new <a href="https://cs.opensource.google/go/x/exp/+/a68e582f:constraints/constraints.go">constraints package</a>, which could include an <code>Integer</code> constraint, but for now, if we need to go further than <i>comparable</i> we must build the constraint ourselves.</p>

</aside>

<p>In this next example, we’ll a create custom constraint <i>Numeric</i> by moving the constraint list into a new interface type.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 121 - Creating a custom constraint</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code>	<code class="s2">"reflect"</code>
<code class="linenos"> 6 </code><code class="p">)</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="nb">type</code> <code class="n">Numeric</code> <code class="n">interface</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="n">int8</code> <code class="o">|</code> <code class="n">int16</code> <code class="o">|</code> <code class="n">int32</code> <code class="o">|</code> <code class="n">int64</code> <code class="o">|</code> <code class="nb">int</code>
<code class="linenos">10 </code><code class="p">}</code>
<code class="linenos">11 </code>
<code class="linenos">12 </code><code class="n">func</code> <code class="n">SumAny</code><code class="p">[</code><code class="n">T</code> <code class="n">Numeric</code><code class="p">](</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">T</code><code class="p">)</code> <code class="n">T</code> <code class="p">{</code>
<code class="linenos">13 </code>	<code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code>
<code class="linenos">14 </code><code class="p">}</code>
<code class="linenos">15 </code>
<code class="linenos">16 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">17 </code>	<code class="n">res</code> <code class="o">:=</code> <code class="n">SumAny</code><code class="p">(</code><code class="n">int16</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code> <code class="n">int16</code><code class="p">(</code><code class="mi">2</code><code class="p">))</code>
<code class="linenos">18 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">res</code><code class="p">)</code>
<code class="linenos">19 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">reflect</code><code class="o">.</code><code class="n">TypeOf</code><code class="p">(</code><code class="n">res</code><code class="p">))</code>
<code class="linenos">20 </code><code class="p">}</code>
<code class="linenos">21 </code>
<code class="linenos">22 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">IxpNJBWPkZo</code>
</pre></div>

</figure>


<p>The output is identical to before, and the <code>SumAny()</code> function signature is simple to read again. As a bonus <i>Numeric</i> is reusable, we can avoid the constraint list in the next generic function that performs addition or subtraction, and instead use the <i>Numeric</i> constraint.</p>

<p>As you might expect, custom constraints, since they are interfaces, are composable. This allows us to build less restrictive constraints by composing from restrictive constraints.</p>

<p>In the next example, we’ll amend the code so that <code>SumAny()</code> can also perform addition on unsigned integers, a glaring omission.  But, rather than use one big constraint list, we will use composition to create the <i>Numeric</i> constraint, by creating and embedding a <i>Signed</i> and <i>Unsigned</i> constraint.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 122 - Using composition with constraints</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code>	<code class="s2">"reflect"</code>
<code class="linenos"> 6 </code><code class="p">)</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="nb">type</code> <code class="n">Numeric</code> <code class="n">interface</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="n">Signed</code> <code class="o">|</code> <code class="n">Unsigned</code>
<code class="linenos">10 </code><code class="p">}</code>
<code class="linenos">11 </code>
<code class="linenos">12 </code><code class="nb">type</code> <code class="n">Unsigned</code> <code class="n">interface</code> <code class="p">{</code>
<code class="linenos">13 </code>	<code class="n">uint8</code> <code class="o">|</code> <code class="n">uint16</code> <code class="o">|</code> <code class="n">uint32</code> <code class="o">|</code> <code class="n">uint64</code> <code class="o">|</code> <code class="n">uint</code>
<code class="linenos">14 </code><code class="p">}</code>
<code class="linenos">15 </code>
<code class="linenos">16 </code><code class="nb">type</code> <code class="n">Signed</code> <code class="n">interface</code> <code class="p">{</code>
<code class="linenos">17 </code>	<code class="n">int8</code> <code class="o">|</code> <code class="n">int16</code> <code class="o">|</code> <code class="n">int32</code> <code class="o">|</code> <code class="n">int64</code> <code class="o">|</code> <code class="nb">int</code>
<code class="linenos">18 </code><code class="p">}</code>
<code class="linenos">19 </code>
<code class="linenos">20 </code><code class="n">func</code> <code class="n">SumAny</code><code class="p">[</code><code class="n">T</code> <code class="n">Numeric</code><code class="p">](</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">T</code><code class="p">)</code> <code class="n">T</code> <code class="p">{</code>
<code class="linenos">21 </code>	<code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code>
<code class="linenos">22 </code><code class="p">}</code>
<code class="linenos">23 </code>
<code class="linenos">24 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">25 </code>	<code class="n">res</code> <code class="o">:=</code> <code class="n">SumAny</code><code class="p">(</code><code class="n">int16</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code> <code class="n">int16</code><code class="p">(</code><code class="mi">2</code><code class="p">))</code>
<code class="linenos">26 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">res</code><code class="p">)</code>
<code class="linenos">27 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">reflect</code><code class="o">.</code><code class="n">TypeOf</code><code class="p">(</code><code class="n">res</code><code class="p">))</code>
<code class="linenos">28 </code><code class="p">}</code>
<code class="linenos">29 </code>
<code class="linenos">30 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="mi">2</code><code class="n">yARr7xNBG8</code>
</pre></div>

</figure>


<p>Kudos to the Go development team! That is incredibly elegant in its simplicity, and the way it builds on what we already know.</p>

<p>But what about custom types?</p>

<p>We can use custom types in constraint lists and constraints, just like built-in types, but Go provides a modifier we can apply to built-in types, so that any user-defined type, which is based on one of the built-in types can be allowed. </p>

<p>Let’s take our example in a slightly different direction to illustrate this.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 123 - Allow any type with underlying type <i>int</i></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code>	<code class="s2">"reflect"</code>
<code class="linenos"> 6 </code><code class="p">)</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="nb">type</code> <code class="n">OnlyInt</code> <code class="n">interface</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="nb">int</code>
<code class="linenos">10 </code>	<code class="o">//</code> <code class="o">~</code><code class="nb">int</code>
<code class="linenos">11 </code><code class="p">}</code>
<code class="linenos">12 </code>
<code class="linenos">13 </code><code class="nb">type</code> <code class="n">myInt</code> <code class="nb">int</code>
<code class="linenos">14 </code>
<code class="linenos">15 </code><code class="n">func</code> <code class="n">SumAny</code><code class="p">[</code><code class="n">T</code> <code class="n">OnlyInt</code><code class="p">](</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="n">T</code><code class="p">)</code> <code class="n">T</code> <code class="p">{</code>
<code class="linenos">16 </code>	<code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code>
<code class="linenos">17 </code><code class="p">}</code>
<code class="linenos">18 </code>
<code class="linenos">19 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">20 </code>	<code class="n">var</code> <code class="n">myInt</code> <code class="n">myInt</code> <code class="o">=</code> <code class="mi">1</code>
<code class="linenos">21 </code>	<code class="n">res</code> <code class="o">:=</code> <code class="n">SumAny</code><code class="p">(</code><code class="n">myInt</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>
<code class="linenos">22 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">res</code><code class="p">)</code>
<code class="linenos">23 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">reflect</code><code class="o">.</code><code class="n">TypeOf</code><code class="p">(</code><code class="n">res</code><code class="p">))</code>
<code class="linenos">24 </code><code class="p">}</code>
<code class="linenos">25 </code>
<code class="linenos">26 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">b8jNMrEtUcL</code>
</pre></div>

</figure>


<p>Output:</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>./prog.go:21:15: myInt does not implement OnlyInt <code class="o">(</code>possibly missing ~ <code class="k">for</code> int <code class="k">in</code> con<code class="se">\</code>
<code class="linenos">2 </code>straint OnlyInt<code class="o">)</code>
<code class="linenos">3 </code>
<code class="linenos">4 </code>Go build failed.
</pre></div>

</figure>


<p>Once again, this code fails to compile, but the compiler message is very helpful. We are trying to pass a value of type <i>myInt</i>, a user-defined type which has the underlying type of <i>int</i>. </p>

<p>If you uncomment line 10, and comment out line 9, this tilde modifier tells the compiler that we will accept any type which has the underlying type of <i>int</i>.</p>

<p>The code should now compile and run, producing the following output.</p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code><code class="m">3</code>
<code class="linenos">2 </code>main.myInt
<code class="linenos">3 </code>
<code class="linenos">4 </code>Program exited.
</pre></div>

</figure>


<p>The last example we’re going to look at demonstrates how we can use multiple type parameters each with its own constraint.  It’s quite contrived but serves to illustrate the point.</p>


<figure class="code with-caption" dir="ltr">
  <figcaption>Example 124 - Multiple type parameters</figcaption>
  <div class="highlight"><pre><code></code><code class="linenos"> 1 </code><code class="n">package</code> <code class="n">main</code>
<code class="linenos"> 2 </code>
<code class="linenos"> 3 </code><code class="kn">import</code> <code class="p">(</code>
<code class="linenos"> 4 </code>	<code class="s2">"fmt"</code>
<code class="linenos"> 5 </code>	<code class="s2">"reflect"</code>
<code class="linenos"> 6 </code><code class="p">)</code>
<code class="linenos"> 7 </code>
<code class="linenos"> 8 </code><code class="n">func</code> <code class="n">MakeAddToMap</code><code class="p">[</code><code class="n">K</code> <code class="n">comparable</code><code class="p">,</code> <code class="n">V</code> <code class="nb">any</code><code class="p">](</code><code class="n">k</code> <code class="n">K</code><code class="p">,</code> <code class="n">v</code> <code class="n">V</code><code class="p">)</code> <code class="nb">map</code><code class="p">[</code><code class="n">K</code><code class="p">]</code><code class="n">V</code> <code class="p">{</code>
<code class="linenos"> 9 </code>	<code class="n">mp</code> <code class="o">:=</code> <code class="n">make</code><code class="p">(</code><code class="nb">map</code><code class="p">[</code><code class="n">K</code><code class="p">]</code><code class="n">V</code><code class="p">)</code>
<code class="linenos">10 </code>	<code class="n">mp</code><code class="p">[</code><code class="n">k</code><code class="p">]</code> <code class="o">=</code> <code class="n">v</code>
<code class="linenos">11 </code>	<code class="k">return</code> <code class="n">mp</code>
<code class="linenos">12 </code><code class="p">}</code>
<code class="linenos">13 </code>
<code class="linenos">14 </code><code class="n">func</code> <code class="n">main</code><code class="p">()</code> <code class="p">{</code>
<code class="linenos">15 </code>	<code class="n">mp</code> <code class="o">:=</code> <code class="n">MakeAddToMap</code><code class="p">(</code><code class="s2">"key"</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>
<code class="linenos">16 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">reflect</code><code class="o">.</code><code class="n">TypeOf</code><code class="p">(</code><code class="n">mp</code><code class="p">))</code>
<code class="linenos">17 </code>	<code class="n">fmt</code><code class="o">.</code><code class="n">Println</code><code class="p">(</code><code class="n">mp</code><code class="p">)</code>
<code class="linenos">18 </code><code class="p">}</code>
<code class="linenos">19 </code>
<code class="linenos">20 </code><code class="o">//</code> <code class="n">Go</code> <code class="n">Playground</code><code class="p">:</code> <code class="n">https</code><code class="p">:</code><code class="o">//</code><code class="n">go</code><code class="o">.</code><code class="n">dev</code><code class="o">/</code><code class="n">play</code><code class="o">/</code><code class="n">p</code><code class="o">/</code><code class="n">DFeMUaFqBzG</code>
</pre></div>

</figure>


<p>Output: </p>


<figure class="code " dir="ltr">
  <figcaption></figcaption>
  <div class="highlight"><pre><code></code><code class="linenos">1 </code>map<code class="o">[</code>string<code class="o">]</code>int
<code class="linenos">2 </code>map<code class="o">[</code>key:1<code class="o">]</code>
<code class="linenos">3 </code>
<code class="linenos">4 </code>Program exited.
</pre></div>

</figure>


<p>Notice that we use the built-in <i>comparable</i> constraint on the <code>K</code> type parameter, as not every type can be used for a map key. If we had specified <i>any</i> the program would have failed to build.</p>

<p>The syntax is again a little confusing, but I suspect as we start to see more generic programming in Go, we’ll get used to it.</p>

<h3 id="leanpub-auto-summary-1" class="subsection">9.6.3 Summary</h3>

<p>We should now have a fairly good grasp of generics. Let’s recap on what we’ve learned.</p>

<p>We know how to apply generic programming to solve some of the types of problems where traditionally we’ve just written more code, or settled for some type assertion. </p>

<p>We’ve seen the complexity generics can introduce into our syntax, and, while accepting that novelty and our unfamiliarity are factors, we’ve discovered ways we can mitigate this with custom constraints and composition, for example.</p>

<p>And, future versions of Go will likely add further features, and it’s likely that more built-in constraints will be introduced which will reduce the footprint of generics further still.</p>

<p>But of course, not everything requires us to apply generics. Often a little duplication is absolutely fine. Such code is often simple to read, and simple to reason about. We must recognise that maintaining code is often the responsibility of a team of developers so we should be considerate of them, and their abilities, especially when applying features which are relatively new, and that not everybody has experience with.</p>


